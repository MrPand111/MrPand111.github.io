{"meta":{"title":"畅喵の博客","subtitle":"请叫我熊猫大人！","description":"华中农业大学的计科菜鸡，大前端研习ing","author":"MrPanda刘畅","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-15T08:50:12.000Z","updated":"2019-08-15T08:51:10.688Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-15T08:49:44.000Z","updated":"2019-08-15T08:50:41.856Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git基本操作","slug":"git基本操作","date":"2019-09-25T10:47:57.000Z","updated":"2019-09-25T13:08:22.484Z","comments":true,"path":"2019/09/25/git基本操作/","link":"","permalink":"http://yoursite.com/2019/09/25/git基本操作/","excerpt":"","text":"一、git创建仓库git init1git init Git的很多命令都需要再Git的仓库中运行，所以git init是使用git的第一个命令。 在执行完git init之后，Git仓库会生成一个.git目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。 git clone12git clone &lt;repo&gt;git clone &lt;repo&gt; &lt;directory&gt; //到指定目录 repo: Git仓库 directory: 本地目录 二、基本操作git add git add命令可将该文件添加到缓存。 我们可以使用下面的命令来添加当前项目的所有文件。 1git add . git status 查看在上次提交之后是否有修改。 该命令加上 -s 参数，以获得简短的结果输出。 1git status git diff 查看执行git status的结果的详细信息。 git diff命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。 尚未缓存的改动：git diff 查看已缓存的改动：git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个diff：git diff –stat git commit 使用git add命令将想要快照的内容写入缓存区，而执行git commit将缓存区内容添加到仓库中。 Git为你的每一个提交都记录，第一步配置用户名和邮箱地址。 config --global user.name 'panda'1git config --global user.email panda@qq.com 如果觉得git add提交缓存的流程太过繁琐，Git也允许用 -a 选项跳过这一步。 1git commit -a 修改文件内容后，执行以下命令 1git commit -m &quot;change something&quot; git reset HEAD git reset HEAD 命令用于取消已缓存的内容。 1git reset HEAD readme.md git rm 如果只是简单地从工作目录中手工删除文件，运行git status时就会在Changes not staged for commit的提示。 要从Git中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。 1git rm &lt;file&gt; 如果删除之前修改过并且已经放到暂存区域的话，则必须要强制删除选项 -f 1git rm -f &lt;file&gt; 三、Git分支管理列出分支 没有参数时，git branch会列出你在本地的分支 1git branch 执行git init的适合，默认情况下Git就会为你创建master分支。手动创建分支： 1git branch branchname 切换分支 切换分支 1git checkout (branch) 可以使用git checkout -b (branchname)来创建新分支并立即切换到该分支下 删除分支 删除本地分支： 12git branch -d (branchname)git branch -D (branchname) //强制删除 删除远程分支： 1git push origin --delete (branchname) 分支合并 一旦某分支有了独立内容，可以使用一下命令将任何分支合并到当前分支中去 1git merge (branchname) push和pull分支 本地推送分支： 1git push origin (branchname) pull分支： 1git pull origin (branchname)","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"单例模式","slug":"单例模式","date":"2019-09-21T05:10:55.000Z","updated":"2019-09-21T06:04:04.346Z","comments":true,"path":"2019/09/21/单例模式/","link":"","permalink":"http://yoursite.com/2019/09/21/单例模式/","excerpt":"单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点","text":"单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点 什么是单例模式例子：在页面中点击登录按钮，弹出了一个登录浮窗，这个登录浮窗是唯一的，无论我们单击多少次，浮窗只会创建一次。单例模式的核心是确保只有一个实例，并提供全局访问。 降低全局污染 使用命名空间 适当使用命名空间，并不会杜绝全局变量，但是可以减少全局变量的数量。 使用闭包封装私有变量 123456789var payen = (function() &#123; var _name = 'panda', _age = 19 return &#123; getinfo: function() &#123; return _name + ' ' + _age &#125; &#125;&#125;)() 变量被封装在了闭包内，只暴露一些接口用于外部通信，从而避免了对全局的命令污染。 简单的惰性单例模式12345678910111213141516var createDiv = (function() &#123; var div return function() &#123; if(!div) &#123; div = document.createElement('div') div.style.width = '100px' div.style.height = '100px' div.style.background = 'red' document.body.appendChild(div) &#125; &#125;&#125;)()createDiv()createDiv()createDiv() 使用单例模式让它只创建一个div 问题： 违反了单一职责原则，创建对象和管理单例放在了一个函数中createDiv 如果我们还想创建一个其他的对象，那就只能copy了 综上，我们需要：把不变的部分隔离出来，把可变的封装起来，这给予了我们扩展程序的能力，符合开发-封闭原则 抽出管理单例12345678910111213141516171819var getSingle = function(fn) &#123; var result return function() &#123; return result || (result = fn.apply(this, arguments)) &#125;&#125;var createDiv = function() &#123; var div = document.createElement('div') div.style.width = '100px' div.style.height = '100px' div.style.background = 'red' document.body.appendChild(div) return div&#125;var createSingDiv = getSingle(createDiv)createSingleDiv()createSingleDiv()createSingleDiv() 创建的DOM节点保存在了result中，result变量因为自身在闭包中，不会被销毁，在将来的请求中，如果result已经被赋值了，那么它将返回这个值。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JavaScript深入(四)——this机制","slug":"JavaScript深入-四-——this机制","date":"2019-09-20T07:16:33.000Z","updated":"2019-09-20T12:48:16.816Z","comments":true,"path":"2019/09/20/JavaScript深入-四-——this机制/","link":"","permalink":"http://yoursite.com/2019/09/20/JavaScript深入-四-——this机制/","excerpt":"this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。","text":"this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。 例子1123456function a() &#123; var user = \"panda\" console.log(this.user) //undefined console.log(this) //Window&#125;a() this最终指向的是调用它的对象，这里的函数a实际是被Window对象所点出来的。 123456function a() &#123; var user = \"panda\" console.log(this.user) //undefined console.log(this) //Window&#125;window.a() 和上面的代码一样，其实alert也是window的一个属性，也是window点出来的。 例子21234567var o = &#123; user: 'panda', fn: function() &#123; console.log(this.user) //panda &#125;&#125;o.fn() 这里的this指向的是对象o，因为你调用这个fn是通过o.fn()执行的，那自然指向就是对象o，this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁。 例子31234567var o = &#123; user: 'panda', fn: function() &#123; console.log(this.user) //panda &#125;&#125;window.o.fn() 再一个例子 123456789var o = &#123; a: 10, b: &#123; a: 12, fn: function() &#123; console.log(this.a) //12 &#125; &#125;&#125; 情况1：如果一个函数中有this，但是他没有被上一级的对象调用，那么this指向的就是window（严格模式不符合）。 情况2：如果一个函数中有this，这个函数又被上一级的对象所调用，那么this指向的就是上一级的对象。 情况3: 如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级对象。 123456789var o = &#123; a: 10, b: &#123; fn: function() &#123; console.log(this.a) //undefined &#125; &#125;&#125;o.b.fn() 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。 特殊情况123456789101112var o = &#123; a: 10, b: &#123; a: 12, fn: function() &#123; console.log(this.a) //undefined console.log(this) //window &#125; &#125;&#125;var j = o.b.fnj() 这里的this指向的是window。this永远指向的是最后调用它的对象。 this碰到return1234567891011121314function fn() &#123; this.user = 'panda' return &#123;&#125;&#125;var a = new fnconsole.log(a.user) //undefinedfunction bn() &#123; this.user = 'panda' return 1&#125;var b = new bnconsole.log(b.user) //panda 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。 补充 严格版中的默认的this操作不再是window，而是undefined。 new操作符会改变函数this的指向问题。","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JavaScript深入(三)——作用域和执行上下文","slug":"JavaScript深入-三-——作用域和执行上下文","date":"2019-09-18T12:33:41.000Z","updated":"2019-09-20T12:48:46.789Z","comments":true,"path":"2019/09/18/JavaScript深入-三-——作用域和执行上下文/","link":"","permalink":"http://yoursite.com/2019/09/18/JavaScript深入-三-——作用域和执行上下文/","excerpt":"作用域 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript采用词法作用域，也就是静态作用域。","text":"作用域 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript采用词法作用域，也就是静态作用域。 静态作用域 因为JavaScript采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。12345678910111213var value = 1function foo() &#123; console.log(value)&#125;function bar() &#123; var value = 2 foo()&#125;bar() 执行foo函数，先从foo函数内部查找是否有局部变量value，如果没有，就根据书写的位置，查找上面一层的代码，也就是value等于1，所以结果会打印1。 顺序执行？例一 12345678var foo = function () &#123; console.log('foo1')&#125;foo() //foo1var foo = function () &#123; console.log('foo2')&#125;foo() //foo2 例二 12345678function foo() &#123; console.log('foo1')&#125;foo() //foo2function foo() &#123; console.log('foo2')&#125;foo() //foo2 可执行代码全局代码、函数代码、eval代码 执行上下文 JavaScript引擎创建了执行上下文栈来管理执行上下文为了模拟执行上下文栈的行为，定义执行上下文栈是一个数组： ECStack = [] 当JavaScript开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用globalContext表示它，并且只有当整个应用程序结束的时候，ECStack才会被清空，所以ECStack最底部永远有个globalContext： 123ECStack = [ globalContext] 现在JavaScript遇到下面这段代码了： 12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3()&#125;function fun1() &#123; fun2()&#125;fun1() 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。 1234567891011121314151617//fun1()ECStack.push(&lt;fun1&gt; functionContext)// fun1调用fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext)//fun2调用fun3ECStack.push(&lt;fun3&gt; functionContext)//fun3执行完毕ECStack.pop()//fun2执行完毕ECStack.pop()//fun1执行完毕ECStack.pop()","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"vue源码分析","slug":"vue源码分析","date":"2019-09-14T07:55:37.000Z","updated":"2019-09-18T12:32:44.434Z","comments":true,"path":"2019/09/14/vue源码分析/","link":"","permalink":"http://yoursite.com/2019/09/14/vue源码分析/","excerpt":"数据代理 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）。 vue数据代理：通过vm对象来处理data中所有属性的操作。 好处：更方便的操作data中的数据。","text":"数据代理 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）。 vue数据代理：通过vm对象来处理data中所有属性的操作。 好处：更方便的操作data中的数据。 123456789const vm = new Vue(&#123; el: '#test', data: &#123; name: 'Panda', &#125;&#125;)console.log(vm.name) //panda vm代理对data数据的读操作vm.name = 'cat' //vm代理对data数据的写操作console.log(vm._data.name) //cat 基本实现流程： 通过Object.defineProperty()给vm添加与data对象的属性对应的属性描述符。 所有添加的属性都包含getter/setter getter/setter内部去操作data中对应的属性数据。 1234567891011121314151617_proxyData: function(key, setter, getter) &#123; //保存vm var me = this; setter = setter || Object.defineProperty(me, key, &#123; configurable: false, //不能重新定义 enumerable: true, //可以枚举遍历 //当通过vm.xxx读取属性值时调用，从data中获取对应的属性值返回 代理读操作 get: function proxyGetter() &#123; return me._data[key]; &#125;, //当通过vm.xxx = value时，value被保存到data中对应的属性上 代理写操作 set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;);&#125; 模板解析模板解析的基本流程 将el的所有子节点取出，添加到一个新建的文档fragment对象中。 对fragment中的所有层次子节点递归进行编译解析处理。 对表达式文本节点进行解析 对元素节点的指令属性进行解析 事件指令解析","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"JavaScript深入(二)——getter与setter的使用","slug":"JavaScript深入-二-——getter与setter的使用","date":"2019-09-12T12:42:08.000Z","updated":"2019-09-13T04:40:14.419Z","comments":true,"path":"2019/09/12/JavaScript深入-二-——getter与setter的使用/","link":"","permalink":"http://yoursite.com/2019/09/12/JavaScript深入-二-——getter与setter的使用/","excerpt":"基本用法定义JavaScript对象的属性是由名字、值和一组特性（可写、柯枚举、可配置等）构成的。属性值可以用一个或两个方法代替，就是getter和setter。 123456789var myObj = &#123; a: 2, get b() &#123; return 3 &#125;&#125;console.log(myObj.a) //2console.log(myObj.b) //3 上面的代码中，属性a称为数据属性，它只有一个简单的值；属性b用getter和setter方法定义的属性称为存取器属性。","text":"基本用法定义JavaScript对象的属性是由名字、值和一组特性（可写、柯枚举、可配置等）构成的。属性值可以用一个或两个方法代替，就是getter和setter。 123456789var myObj = &#123; a: 2, get b() &#123; return 3 &#125;&#125;console.log(myObj.a) //2console.log(myObj.b) //3 上面的代码中，属性a称为数据属性，它只有一个简单的值；属性b用getter和setter方法定义的属性称为存取器属性。 特性 存取器属性定义为一个或两个与属性同名的函数。 当程序查询存取器的属性值时，JavaScript调用getter方法（无参数），这个方法的返回值就是该属性存取表达式的值。当程序设置一个存取器属性值时，JavaScript调用setter方法，将赋值表达式右侧的值当作参数传入setter，将赋值表达式右侧的值当作参数传入setter。从某种意义上来说，这个方法负责设置属性值，可以忽略该方法的返回值。 当一个属性被定义为存取器属性时，JavaScript会忽略它的value和writable特性，取而代之的是set和get（还有configurable和enumerable）特性。 12345678910var myObj = &#123; get a() &#123; return this._a_; &#125;, set a(val)&#123; this._a_ = val &#125;&#125;myObj.a = 3console.log(myObj.a) //3 getter和setter方法中的this都指向myObj对象。 存取器属性也是可以继承的： 12var anotherObj = Object.create(myObj)console.log(another.a) //3 Object.defineProperty语法 Object.defineProperty(obj,prop,descriptor)，该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。 参数： obj：要在其上定义属性的对象。 prop：要定义或修改的属性的名称。 descriptor：将被定义或修改的属性描述符。 属性描述符： configurable：当且仅当该属性的configurable为true时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为false。 enumerable：当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为false。 value：该属性对应的值，可以是任何有效的JavaScript值（数值，对象，函数等）。默认为undefined。 writable：当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为false。 get：一个给属性提供getter的方法，如果没有getter则为undefined。当访问该属性时，该方法被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为undefined。 set：一个给属性提供setter的方法，如果没有setter则为undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。 示例123456789101112131415161718192021var o = &#123;&#125; //创建一个新对象Object.defineProperty(o,\"a\",&#123; value: 37, writable: true, enumerable: true, configurable: true&#125;)// 对象o拥有了属性a，值为37var bValueObject.defineProperty(o,\"b\", &#123; get: function() &#123; return bValue &#125;, set: function(newValue) &#123; bValue = newValue &#125;, enumerable: true, configurable: true&#125;)","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JavaScript深入(一)——原型链","slug":"JavaScript深入-一-——原型链","date":"2019-09-12T07:34:37.000Z","updated":"2019-09-12T11:38:03.083Z","comments":true,"path":"2019/09/12/JavaScript深入-一-——原型链/","link":"","permalink":"http://yoursite.com/2019/09/12/JavaScript深入-一-——原型链/","excerpt":"构造函数创建对象123456function Person() &#123;&#125;var person = new Person()person.name = 'Panda'console.log(person.name) // Panda 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象person。","text":"构造函数创建对象123456function Person() &#123;&#125;var person = new Person()person.name = 'Panda'console.log(person.name) // Panda 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象person。 prototype每个函数都有一个prototype属性。 12345678function Person() &#123;&#125;Person.prototype.name = 'Panda'var person1 = new Person()var person2 = new Person()console.log(person1.name) // Pandaconsole.log(person2.name) // Panda 其实，函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是person1和person2的原型。 原型：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。 proto这是每一个JavaScript对象（除了null）都具有的一个属性，叫_proto_，这个属性会指向该对象的原型。 12345function Person() &#123;&#125;var person = new Person()console.log(person._proto_ === Person.prototype) //true constructor每一个原型都有一个constructor属性指向关联的构造函数。 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor) //true 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 1234567891011function Person() &#123;&#125;Person.prototype.name = 'Panda'var person = new Person()person.name = 'Cat'console.log(person.name) //Catdelete person.nameconsole.log(person.name) //Panda 原型的原型原型也是一个对象，既然是对象，就可以用最原始的方法创建它。 123var obj = new Object()obj.name = 'Panda'console.log(obj.name) //Panda 其实原型对象就是通过Object构造函数生成的，实例的_proto_指向构造函数的prototype。 Object.prototype没有原型（_proto_的值为null） 查找属性的时候查到Object.prototype就可以停止查找了。 补充constructor1234function Person() &#123; var person = new Person() console.log(person.constructor === Person) //true&#125; 当获取person.constructor时，其实person中并没有constructor属性，当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有该属性。 继承关于继承，引用《你不知道的JavaScript》中的话 继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更精确些。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"flex布局","slug":"flex布局","date":"2019-09-01T07:41:29.000Z","updated":"2019-09-02T01:19:59.309Z","comments":true,"path":"2019/09/01/flex布局/","link":"","permalink":"http://yoursite.com/2019/09/01/flex布局/","excerpt":"flex-direction属性 决定主轴的方向（即项目的排列方向） row(默认值)：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。","text":"flex-direction属性 决定主轴的方向（即项目的排列方向） row(默认值)：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性 默认情况下，项目都排在轴线上，flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-content属性 定义了项目在主轴上的对齐方式。 flex-start(默认值)：左对齐。 flex-end：右对齐。 center：居中。 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性 定义项目在交叉轴上如何对齐 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline：项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认）：轴线占满整个交叉轴。 选择单个元素 html 12345&lt;article&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/article&gt; css 123456article:first-child&#123; align-self: flex-start;&#125;article:nth-child(2)&#123; align-self:center;&#125; flex-grow属性 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis属性 定义了在分配多于空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值，则项目将占据固定空间。 flex属性 是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。 order属性 定义项目的排列顺序。数值越小，排列越靠前，默认为0 定位元素在弹性布局中的表现 绝对定位没有了空间位，flex布局会失效。 相对定位保留了空间位，flex布局仍有效果。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"转载：JS中的块级作用域，var、let、const三者的区别","slug":"转载：JS中的块级作用域，var、let、const三者的区别","date":"2019-08-22T02:08:30.000Z","updated":"2019-08-22T02:15:29.917Z","comments":true,"path":"2019/08/22/转载：JS中的块级作用域，var、let、const三者的区别/","link":"","permalink":"http://yoursite.com/2019/08/22/转载：JS中的块级作用域，var、let、const三者的区别/","excerpt":"首先，ECMAScript和JavaScript关系： ECMAScript是一个国际通过的标准化脚本语言。JavaScript由ECMAScript和DOM、BOM三者组成。可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。","text":"首先，ECMAScript和JavaScript关系： ECMAScript是一个国际通过的标准化脚本语言。JavaScript由ECMAScript和DOM、BOM三者组成。可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。 1.块作用域{ }JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。 块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &#123; var a = 1; console.log(a); // 1&#125;console.log(a); // 1// 可见，通过var定义的变量可以跨块作用域访问到。(function A() &#123; var b = 2; console.log(b); // 2&#125;)();// console.log(b); // 报错，// 可见，通过var定义的变量不能跨函数作用域访问到if(true) &#123; var c = 3;&#125;console.log(c); // 3for(var i = 0; i &lt; 4; i++) &#123; var d = 5;&#125;;console.log(i); // 4 (循环结束i已经是4，所以此处i为4)console.log(d); // 5// if语句和for语句中用var定义的变量可以在外面访问到，// 可见，if语句和for语句属于块作用域，不属于函数作用域。&#123; var a = 1; let b = 2; const c = 3; &#123; console.log(a); // 1 子作用域可以访问到父作用域的变量 console.log(b); // 2 子作用域可以访问到父作用域的变量 console.log(c); // 3 子作用域可以访问到父作用域的变量 var aa = 11; let bb = 22; const cc = 33; &#125; console.log(aa); // 11 // 可以跨块访问到子 块作用域 的变量 // console.log(bb); // 报错 bb is not defined // console.log(cc); // 报错 cc is not defined&#125;2.var、let、const的区别 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。 同一个变量只能使用一种方式声明，不然会报错 12345678910111213141516171819202122232425262728293031323334353637// 块作用域&#123; var a = 1; let b = 2; const c = 3; // c = 4; // 报错 // let a = 'a'; // 报错 注：是上面 var a = 1; 那行报错 // var b = 'b'; // 报错：本行报错 // const a = 'a1'; // 报错 注：是上面 var a = 1; 那行报错 // let c = 'c'; // 报错：本行报错 var aa; let bb; // const cc; // 报错 console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 console.log(aa); // undefined console.log(bb); // undefined&#125;console.log(a); // 1// console.log(b); // 报错// console.log(c); // 报错// 函数作用域(function A() &#123; var d = 5; let e = 6; const f = 7; console.log(d); // 5 console.log(e); // 6 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到) console.log(f); // 7 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到)&#125;)();// console.log(d); // 报错// console.log(e); // 报错// console.log(f); // 报错 ————————————————版权声明：本文为CSDN博主「hot_cool」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/hot_cool/article/details/78302673","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-08-21T03:13:37.000Z","updated":"2019-08-21T14:10:27.062Z","comments":true,"path":"2019/08/21/正则表达式/","link":"","permalink":"http://yoursite.com/2019/08/21/正则表达式/","excerpt":"正则表达式 正则表达式是国际标准，跨越语言 正则表达式是一个规则，用于验证字符串","text":"正则表达式 正则表达式是国际标准，跨越语言 正则表达式是一个规则，用于验证字符串 基础 创建正则表达式的对象 创建正则表达式的对象 12345//var 变量 = new RegExp(\"正则表达式\",\"匹配模式\")//使用typeof检查正则对象，会返回object//RegExp(\"a\")这个正则表达式可以检查一个字符串是否含有alet reg = new RegExp(\"a\",\"i\")let str = \"a\" 在构造函数中可以传递一个匹配模式作为第二个参数：可以是 i 忽略大小写 g 全局匹配模式 正则表达式的基本方法 test() 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false123let result = reg.test(str)console.log(result) //trueconsole.log(reg.test(\"bcbc\")) //false 严格区分大小写 使用字面量来创建正则表达式 语法：let 变量 = /正则表达式/匹配模式 1let reg = /a/i 创建一个正则表达式，检查一个字符串中是否有a或b 12345678let reg = /a|b/i //使用 | 表示或者的意思console.log(reg.test(\"ac\")) //true``` - 创建一个正则表达式检查一个字符串中是否有字母``` javascriptlet reg = /[a-z]/i //[]里的内容也是或的关系console.log(reg.test(\"h\")) //true 检查一个字符串中是否含有abc 或 adc 或 aec 12let reg = /a[bde]c/console.log(reg.test(\"aec\")) //true [^ ] 除了 12let reg = /[^ab]/iconsole.log(reg.test(\"abc\")) //true 除了ab还有c 支持正则表达式的String对象的方法 split()可以将一个字符串拆分为一个数组 123let str = \"1a2b3c4d5e6f7\"let result = str.split(/[A-z]/)console.log(result) //\"1,2,3,4,5,6,7\" search()可以搜索字符串中是否含有指定内容,如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1，它可以接收一个正则表达式作为参数，然后回根据正则表达式去检索字符串,不会全局匹配 12345678let str = \"hello abc hello abc\"result = str.search(\"abc\")console.log(result) //6//搜索字符串中是否含有abc 或aec 或afcstr = \"hello hello aec afc\"result = str.search(/a[bef]c/)console.log(result) //12 match()可以根据正则表达式，从一个字符串中将符合条件的内容提取出来,默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索，我们可以设置为全局匹配模式，这样就会匹配到所有的内容 123let str = \"1a2b3c4d5e6f7A8\"let result = str.match(/[a-z]/gi)console.log(result) //\"a,b,c,d,e,f,A\" replace()可以将字符串中指定内容替换为新的内容，参数：被替换的内容、新的内容，默认只会替换第一个 123let str = \"1a2a3c4d5e6f7A8\"let result = str.replace(/a/gi,\"@\")console.log(result) //\"1@2@3c4d5e6f7@8\" 语法 量词 通过变量可以设置一个内容出现的次数 量词只对它前边的一个内容起作用 {n}正好出现 n 次 {m,n} 出现 m 到 n 次 {m,} 出现 m 次以上 + 至少一个，相当于{1,} * 0个或多个，相当于{0,} ? 0个或1个，相当于{0,1} 12345678let reg = /a&#123;3&#125;/ //aaareg = /(ab)&#123;3&#125;/ //abababreg = /ab&#123;3&#125;c/ //abbbcreg = /ab&#123;1,3&#125;c/ //abc abbc abbbcreg = /ab+c/ //至少一个breg = /ab*c/ //有没有b都行reg = /ab?c/ //0个或1个b 检查一个字符串是否以a开头结尾 ^ 表示开头 1reg = /^a/ $表示结尾 1reg = /a$/ 如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式 12reg = /^a$/ reg = /^a|a$/ //以a开头或以a结尾 练习：创建一个正则表达式，用来检查一个字符串是否是一个合法手机号 手机号的规则：11位、以1开头、第二位3-9任意数字、三位以后任意数字9个 ^1 [3-9] [0-9]{9}$12345let phoneStr = \"13567890123\"let wrongStr = \"10567890123\"let phoneReg = /^1[3-9][0-9]&#123;9&#125;$/console.log(phoneReg.test(phoneStr)) //trueconsole.log(phoneReg.test(wrongStr)) //false 检查一个字符串中是否含有. . 表示任意字符 在正则表达式中使用\\作为转义字符 . 来表示 . \\ 来表示 \\ 注意：使用构造函数时，由于它的参数是一个字符串，而\\是字符串中转义字符，如果要使用\\则需要使用\\来代替 有特殊意义的字符 \\w 任意字母、数字、下划线 [A-z0-9_] \\W 除了字母、数字、下划线 [^A-z0-9_] \\d 任意数字 [0-9] \\D 除了数字 [^0-9] \\s 空格 \\S 除了空格 \\b 单词边界 （/\\bchild\\b/ 和 children） \\B 除了单词边界123//去掉开头和结尾的空格let str = \" hello world \"str = str.replace(/^\\s*|\\s$/g,\"\") 邮箱的正则 电子邮箱的格式 任意字母数字下划线 . 任意字母数字下划线 @ 任意字母数字 . 任意字母（2-5位） . 任意字母（2-5位） 正则写法: \\w{3,} (.\\w+)* @ [A-z0-9]+ (.[A-z]{2,5}){1,2} 代码 1let emailReg = /^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"js中常用的数组和字符串方法","slug":"js中数组方法","date":"2019-08-19T06:31:27.000Z","updated":"2019-08-19T08:25:39.519Z","comments":true,"path":"2019/08/19/js中数组方法/","link":"","permalink":"http://yoursite.com/2019/08/19/js中数组方法/","excerpt":"数组栈方法 push() 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。该方法会改变数组的长度。 pop() 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。该方法会改变数组的长度。","text":"数组栈方法 push() 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。该方法会改变数组的长度。 pop() 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。该方法会改变数组的长度。 队列方法 shift() 能够移除数组中的第一项并返回该项，同时将数组长度减1。该方法会改变数组的长度。 unshift() 在数组前端添加任意个项并返回新数组的长度。该方法会改变数组的长度。 重排序方法 reverse() 用于颠倒数组中元素的顺序,会改变原来的数组，而不会创建新的数组。 sort() 对数组中的元素照字符编码的顺序进行排序,数组在原数组上进行排序，不生成副本,要想按照数值大小排序，还要使用一个排序函数。 操作方法 concat() 基于当前数组中的所有项创建一个新数组。具体来说，会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。 slice() 基于当前数组中的一或多个项创建一个新数组。在只有一个参数的情况下，返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法会返回起始和结束位置之间的项（不包括结束位置的项）。slice()方法不会影响原始数组。 splice() 主要用途是向数组的中部插入项。删除：两个参数，要删除的第一项的位置和要删除的项数；插入：三个参数，起始位置、0和要插入的项；替换：三个参数，起始位置、要删除的项数和要插入的任意数量的项。splice()方法始终都会返回一个包含从原始数组中删除的项的数组（如果没删，就返回空数组）。该方法会改变原始数组。 位置方法 indexOf() 接收两个参数，要查找的项和（可选）表示查找起点位置的索引，indexOf()从数组的开头开始（位置0）往后查找.返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。 lastIndexOf() 从数组的末尾开始向前查找。 迭代方法都会对数组中的每一项运行给定函数，都不会改变原始数组。 every() 如果该函数对每一项都返回true，则返回true。 filter() 返回该函数会返回true的项组成的数组。 forEach() 这个方法没有返回值。 map() 返回每次函数调用的结果组成的数组。 some() 如果该函数对任一项返回true，则返回true。 归并方法 reduce() 接收两个参数，在每一项上调用的函数和（可选）作为归并基础的初始值。传给reduce()的函数接受四个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。 reduceRight() 从数组的最后一项开始，向前遍历到第一项。 字符串 charAt() 接收一个参数，字符在字符串中的位置，返回指定位置的字符。 concat() 方法同数组。 indexOf() 方法同数组。区分大小写。 includes() 用于判断字符串是否包含指定字串，如果找到匹配的字符串则返回true，否则返回false。 match() 在字符串内检索指定的项，或找到一个或多个（是否具有标志g）正则表达式的匹配。如果没有找到，将返回null。否则，返回一个数组。 repeat() 接收一个参数，要复制的次数。返回复制指定次数并连接在一起的新字符串。 replace() 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。返回一个新的字符串。该方法不会改变原始字符串。 search() 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回相匹配的String对象起始位置。没有找到则返回-1。 slice() 方法同数组。 split() 用于把一个字符串分割成字符串数组。split() 方法不改变原始字符串。 substr() 可在字符串中抽取从开始下标开始的指定数目的字符。参数是字串的开始位置和长度。该方法不会改变源字符串。 substring() 用于提取字符串中介于两个指定下标之间的字符。返回的子串包括开始处的字符，不包括结束处的字符。 toLowerCase() &amp; toUpperCase() 用于把字符串转换为小/大写，该方法不会改变源字符串。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"c语言快速入门(by 畅喵的瞎扯)","slug":"c语言快速入门-by-畅喵的瞎扯","date":"2019-08-18T09:01:54.000Z","updated":"2019-08-19T08:30:28.616Z","comments":true,"path":"2019/08/18/c语言快速入门-by-畅喵的瞎扯/","link":"","permalink":"http://yoursite.com/2019/08/18/c语言快速入门-by-畅喵的瞎扯/","excerpt":"给我负责的新人写快速入门，没事儿的话就更新点。 一、搭建c语言运行环境和c语言编辑器 如果你是第一次了解到编程的小白，也许你会对c语言这个名词很陌生，它是一种通用的、面向过程式的计算机程序设计语言。没懂？那你可以简单理解为利用一些字母和数字实现某种逻辑的工具，将人脑需要复杂计算出来的东西通过计算机一步就得出结果，当然这堆字母和数字肯定是没有计算功能的神通，但是通过编译这一方法就可以将你所写下的字母数字转化成计算机认识的机器语言，而c语言也是众多计算机语言中最接近机器语言的。","text":"给我负责的新人写快速入门，没事儿的话就更新点。 一、搭建c语言运行环境和c语言编辑器 如果你是第一次了解到编程的小白，也许你会对c语言这个名词很陌生，它是一种通用的、面向过程式的计算机程序设计语言。没懂？那你可以简单理解为利用一些字母和数字实现某种逻辑的工具，将人脑需要复杂计算出来的东西通过计算机一步就得出结果，当然这堆字母和数字肯定是没有计算功能的神通，但是通过编译这一方法就可以将你所写下的字母数字转化成计算机认识的机器语言，而c语言也是众多计算机语言中最接近机器语言的。 想要自己写一段c语言程序，就需要一个像模像样的编辑器，这里推荐code blocks(学校的课程与考试都是用的cb)，你可以在codeblocks官网上下载(mingw是c语言的运行环境，也要一同下载哦)，如果选择的压缩包版的解压即可，安装版的直接装就好了。下图给出了供参考的下载项。 打开code blocks之后可能会提示一些关于environment即环境的问题，这大概率是需要添加c语言的环境变量，这一步自行百度就可以了(一点提示：把c语言源文件夹下的bin添加到我的电脑高级设置中环境变量的path)，如果始终无法解决环境变量的问题，就用w3c或者菜鸟教程的在线编辑器吧，手机中也可以下载c语言的编辑器app，如果仅仅是为了练习代码，甚至用手机记事本都可以。 二、我的第一个c语言程序 每接触一种新的语言肯定要先敲hello world啦。打开codeblocks之后，点击左上角的【file】 -&gt; 【New】 -&gt; 【File】 选择c/c++ source，然后选择c语言，在创建的页面中填好路径与名称（下面Add file..那个不用选），点击【finish】就可以了，下面给出了hello world的示例代码12345678#include&lt;stdio.h&gt;int main()&#123; /* 这是两 段注释 */ printf(\"hello world\"); //另一种注释方式 return 0;&#125; 敲完之后，在菜单栏里找到【build】，选择【build and run】，几秒之后，就可以看到突然蹦出来了一个命令提示框，显示着你刚才敲的hello world 现在我们来分析下这几行代码：第一行的代码叫做头文件，就是写在一个c语言程序最前面的地方咯。stdio.h是c语言的库，库就好比工具箱，里面有很多实现各种功能的工具。include，正如它的释义“包含”一样， 这一行代码翻译过来就是：“这个程序包含了c语言的库”，所以在接下来引用c语言库里的工具或方法就合乎情理了。 第二行是程序的主函数，main即凸显出一个主要的感觉，所有的代码都从主函数开始执行，正因为里面的代码和主函数是包含的关系，所以下面用一个大括号把要执行的代码包裹起来，为了视觉效果上更能展示出包含的关系，括号内部的代码要空四个格。 代码的内容里是没有中文的(包括双引号、括号、分号都是英文的)，但是可以写中文的注释，就是字面意思，对于同一个问题一万个人有一万种代码的写法，为了让别人清楚你的代码干了些什么，有什么要注意的地方，都可以写成注释，/**/就像括号一样，里面的内容都是注释；//的话只能注释一行，从上面的例子就可以看出来 hello world是怎么被显示出来的呢？就是靠着库函数printf。库函数相当于头文件中stdio.h这一工具箱里面的工具(现在清楚头文件的作用了吧),正因为你引入了c语言的头文件，才能在这里使用它的库函数。printf中有单词print“打印”，顾名思义，就是把printf中所包含的内容打印显示在命令提示框中。 return的中文含义是“返回”，0即为空，结束的意思，连接起来就是“回归虚无”(听上去好修仙的感觉)的意思，这也说明了这个程序走到了终点，代码到这里也就结束了。现在是不是对c语言有了一丝丝了解呢，可以试着去敲一个这样的小程序，输出不同的内容哈。 (持续更新中，敬请期待)","categories":[{"name":"cs课程","slug":"cs课程","permalink":"http://yoursite.com/categories/cs课程/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://yoursite.com/tags/c语言/"}]},{"title":"关于如何搭建自己的hexo博客","slug":"关于如何搭建自己的hexo博客","date":"2019-08-15T03:36:04.000Z","updated":"2019-08-16T12:03:24.756Z","comments":true,"path":"2019/08/15/关于如何搭建自己的hexo博客/","link":"","permalink":"http://yoursite.com/2019/08/15/关于如何搭建自己的hexo博客/","excerpt":"一、环境准备 下载node.js(在官网下载就可以了，之后无脑点击下一步安装，安装好之后可以在cmd( win键 + R 打开运行，在里面输入cmd就可以进入cmd了 )里输入: node –version 检查版本，有版本就说明安装好了，在下载node的时候也会绑定下载npm，用同样的方法在cmd里输入: npm –version 看下npm装上了没有) npm上下载的资源比较慢，所以我们用国内的淘宝镜像cnpm，用npm安装cnpm: npm install -g cnpm –registry=https://registry.npm.taobao.org (记得cnpm -v检查下版本哦)","text":"一、环境准备 下载node.js(在官网下载就可以了，之后无脑点击下一步安装，安装好之后可以在cmd( win键 + R 打开运行，在里面输入cmd就可以进入cmd了 )里输入: node –version 检查版本，有版本就说明安装好了，在下载node的时候也会绑定下载npm，用同样的方法在cmd里输入: npm –version 看下npm装上了没有) npm上下载的资源比较慢，所以我们用国内的淘宝镜像cnpm，用npm安装cnpm: npm install -g cnpm –registry=https://registry.npm.taobao.org (记得cnpm -v检查下版本哦) 下载Git，同样是在官网下载，下载安装完成后(记得安装的路径)在桌面一空白区域右键，看下是否出现了两个Git GUI 和 Git Bash的选项，如果有的话在cmd中输入: git –version ，查看一下版本号，可能这里cmd提示说找不到git这个命令，这就表明需要添加环境变量，具体操作自行百度，非常简单，path里加一个路径即可 安装hexo: cnpm install -g hexo-cli (hexo -v检查版本) 二、创建博客 创建一个文件夹存放博客的所有资源,可以在cmd里直接创建，或者去到某个文件夹里新建文件夹都是可以的(我这里直接在默认的我的文档下创建了一个叫blog的文件夹) 1C:\\Users\\23163&gt;mkdir blog 在cmd中移动到你这个新建文件夹中(我这里直接cd blog就可以了) 初始化hexo，看到终端提示：INFO Start blogging with Hexo! 就说明初始化成功了 1C:\\Users\\23163\\blog&gt;hexo init 在cmd中执行命令: hexo s (hexo serve的简写形式)，就可以在本地服务器运行你的hexo博客了，会给一个默认的端口( INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. )，想要退出的话，就像它提示的那样在终端输入Ctrl+C就可以了 在cmd中执行命令: hexo n “我的第一篇博客文章” (hexo new “XXX”的简写形式)，就会为你创建一篇新的博客了，博客的格式为markdown，你可以通过vim或者vscode都可以对博客的内容进行操作 在cmd中执行命令: hexo clean 这一步是清除原有的静态文件(当你更新了配置、主题、内容有可能无法显示，直接清除原有的静态文件再创建新的静态文件是稳妥的方法) 在cmd中执行命令: hexo g (hexo generate的简写形式)，生成包括html、css、js、图片等各种静态文件 再次执行 hexo s 命令，就可以看到刚刚创建的文章被添加到博客里了 三、部署博客到Github 退出刚才在运行的本地博客，在cmd中执行命令,安装部署的工具(记得还是在之前新建的blog文件夹下) 1C:\\Users\\23163\\blog&gt;cnpm install --save hexo-deployer-git 需要你拥有一个GitHub账号，登录你的GitHub，创建一个仓库【create a new repository】，仓库名的格式为：Owner.github.io 其中Owner是你GitHub的名字，这里一定要用这个名字才可以，描述随便写就可以了，创建好仓库后，记录下它的https地址 打开blog文件夹中的_config.yml文件，移动到该文件内容的最底端#Depolyment部分，加上配置，这里的rope换成你自己刚才设置的地址就可以(敲代码的时候注意缩进为两格，冒号后面需要一个空格) 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/MrPand111/MrPand111.github.io.git branch: master 返回到cmd,执行命令: hexo d (hexo deploy的简写形式)，中途需要你登录GitHub账户，登录一下就可以，如果遇到了 Error: Spawn failed，应该是你之前没有在git配置过信息导致的，在cmd中执行: git config –global user.email “you@example.com“ 和 git config –global user.name “Your Name” (双引号里输入你的GitHub信息就行)，然后再次hexo d估计就没问题了 到这里你就可以通过刚才设置的 Owner.github.io 来访问自己的博客了，这里拿我的博客作为示范: https://mrpand111.github.io/ 欢迎大家一起来讨论和深入研究hexo鸭！","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"JS实现一个简单的计算器","slug":"我的第一篇博客文章","date":"2019-08-15T01:15:04.000Z","updated":"2019-08-16T12:53:37.128Z","comments":true,"path":"2019/08/15/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2019/08/15/我的第一篇博客文章/","excerpt":"Part1 HTML + CSShtml部分的话非常简单，利用表格就可以完成,值得一提的就是显示框这里虽然用的是input，但是要加一个只读属性","text":"Part1 HTML + CSShtml部分的话非常简单，利用表格就可以完成,值得一提的就是显示框这里虽然用的是input，但是要加一个只读属性 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id=\"counter\"&gt; &lt;div class=\"counter_window\"&gt;&lt;input type=\"text\" id=\"counter_window\" readonly=\"readonly\"&gt;&lt;/div&gt; &lt;table id=\"table1\"&gt; &lt;tr&gt; &lt;td&gt;7&lt;/td&gt; &lt;td&gt;8&lt;/td&gt; &lt;td&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;.&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td style=\"font-weight: normal;font-size: 14px;\"&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table id=\"table2\"&gt; &lt;tr&gt;&lt;td&gt;/&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;x&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;+&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=\"background: rgb(255, 214, 80); color: white;\"&gt;=&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt; css也是用一些基本的把大小位置固定就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#counter&#123; width:300px; height:507px; border: 1px solid black; margin:100px auto;&#125;.counter_window&#123; width:300px; height:100px; text-align: center;&#125;#counter_window&#123; width:295px; height:100px; text-align: right; font-size: 20px;&#125;#table1&#123; width:215px; height:400px; margin-top:7px; margin-left:10px; float:left;&#125;#table1 td&#123; width:68px;&#125;#table2&#123; width:75px; height:400px; margin-top:7px; float:left; background:#eee;&#125;td&#123; text-align: center; font-size: 18px; cursor: pointer; font-weight: bold;&#125;td:hover&#123; background: skyblue;&#125; Part2 JSjs这里我选择了一个比较投机的方法，eval函数，将字符串转换成js可以看懂的式子计算出来并返回结果，这个函数可以说是双刃剑，优点在于快速方便的解析字符串，缺点就是可以解析一些恶意的代码 1234567891011121314151617181920212223242526//获取视窗const cWindow = document.getElementById('counter_window')//定义要计算的字符串和计算的结果let allStr = \"\"let result//将键入的数字添加到待计算的字符串中function Add(num)&#123; allStr =allStr + num cWindow.value = allStr&#125;//计算字符串function Computed()&#123; result = String(eval(allStr)) allStr = Number(result) cWindow.value = allStr&#125;//Del删除字符串function Del()&#123; allStr = String(cWindow.value).slice(0,allStr.length-1) console.log(allStr) cWindow.value = allStr&#125; Part3 完整代码完成了这个计算器后，应该就对js自定义函数的应用有了一点了解吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;简单计算器&lt;/title&gt; &lt;style&gt; #counter&#123; width:300px; height:507px; border: 1px solid black; margin:100px auto; &#125; .counter_window&#123; width:300px; height:100px; text-align: center; &#125; #counter_window&#123; width:295px; height:100px; text-align: right; font-size: 20px; &#125; #table1&#123; width:215px; height:400px; margin-top:7px; margin-left:10px; float:left; &#125; #table1 td&#123; width:68px; &#125; #table2&#123; width:75px; height:400px; margin-top:7px; float:left; background:#eee; &#125; td&#123; text-align: center; font-size: 18px; cursor: pointer; font-weight: bold; &#125; td:hover&#123; background: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"counter\"&gt; &lt;div class=\"counter_window\"&gt;&lt;input type=\"text\" id=\"counter_window\" readonly=\"readonly\"&gt;&lt;/div&gt; &lt;table id=\"table1\"&gt; &lt;tr&gt; &lt;td onclick=\"Add('7')\"&gt;7&lt;/td&gt; &lt;td onclick=\"Add('8')\"&gt;8&lt;/td&gt; &lt;td onclick=\"Add('9')\"&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=\"Add('4')\"&gt;4&lt;/td&gt; &lt;td onclick=\"Add('5')\"&gt;5&lt;/td&gt; &lt;td onclick=\"Add('6')\"&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=\"Add('1')\"&gt;1&lt;/td&gt; &lt;td onclick=\"Add('2')\"&gt;2&lt;/td&gt; &lt;td onclick=\"Add('3')\"&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=\"Add('.')\"&gt;.&lt;/td&gt; &lt;td onclick=\"Add('0')\"&gt;0&lt;/td&gt; &lt;td onclick=\"Del()\" style=\"font-weight: normal;font-size: 14px;\"&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table id=\"table2\"&gt; &lt;tr&gt;&lt;td onclick=\"Add('/')\"&gt;/&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td onclick=\"Add('*')\"&gt;x&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td onclick=\"Add('-')\"&gt;-&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td onclick=\"Add('+')\"&gt;+&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=\"background: rgb(255, 214, 80); color: white;\" onclick=\"Computed()\"&gt;=&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const cWindow = document.getElementById('counter_window') let allStr = \"\" let result function Add(num)&#123; allStr =allStr + num cWindow.value = allStr &#125; function Computed()&#123; result = String(eval(allStr)) if(result.length === 18)&#123; result = result.slice(0,17) &#125; allStr = Number(result) cWindow.value = allStr &#125; function Del()&#123; allStr = String(cWindow.value).slice(0,allStr.length-1) console.log(allStr) cWindow.value = allStr &#125;&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]}]}