{"meta":{"title":"畅喵の博客","subtitle":"请叫我熊猫大人！","description":"华中农业大学的计科菜鸡，大前端研习ing","author":"MrPanda刘畅","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-15T08:50:12.000Z","updated":"2019-08-15T08:51:10.688Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-15T08:49:44.000Z","updated":"2019-08-15T08:50:41.856Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript深入(一)——原型链","slug":"JavaScript深入-一-——原型链","date":"2019-09-12T07:34:37.000Z","updated":"2019-09-12T10:33:48.402Z","comments":true,"path":"2019/09/12/JavaScript深入-一-——原型链/","link":"","permalink":"http://yoursite.com/2019/09/12/JavaScript深入-一-——原型链/","excerpt":"构造函数创建对象123456function Person() &#123;&#125;var person = new Person()person.name = 'Panda'console.log(person.name) // Panda 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象person。","text":"构造函数创建对象123456function Person() &#123;&#125;var person = new Person()person.name = 'Panda'console.log(person.name) // Panda 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象person。 prototype每个函数都有一个prototype属性。 12345678function Person() &#123;&#125;Person.prototype.name = 'Panda'var person1 = new Person()var person2 = new Person()console.log(person1.name) // Pandaconsole.log(person2.name) // Panda 其实，函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是person1和person2的原型。 原型：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。 proto这是每一个JavaScript对象（除了null）都具有的一个属性，叫_proto_，这个属性会指向该对象的原型。 12345function Person() &#123;&#125;var person = new Person()console.log(person._proto_ === Person.prototype) //true constructor每一个原型都有一个constructor属性指向关联的构造函数。 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor) //true 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 1234567891011function Person() &#123;&#125;Person.prototype.name = 'Panda'var person = new Person()person.name = 'Cat'console.log(person.name) //Catdelete person.nameconsole.log(person.name) //Panda 原型的原型原型也是一个对象，既然是对象，就可以用最原始的方法创建它。 123var obj = new Object()obj.name = 'Panda'console.log(obj.name) //Panda 其实原型对象就是通过Object构造函数生成的，实例的_proto_指向构造函数的prototype。 Object.prototype没有原型（_proto_的值为null） 查找属性的时候查到Object.prototype就可以停止查找了。 补充constructor1234function Person() &#123; var person = new Person() console.log(person.constructor === Person) //true&#125; 当获取person.constructor时，其实person中并没有constructor属性，当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有该属性。 继承关于继承，引用《你不知道的JavaScript》中的话 继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更精确些。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"flex布局","slug":"flex布局","date":"2019-09-01T07:41:29.000Z","updated":"2019-09-02T01:19:59.309Z","comments":true,"path":"2019/09/01/flex布局/","link":"","permalink":"http://yoursite.com/2019/09/01/flex布局/","excerpt":"flex-direction属性 决定主轴的方向（即项目的排列方向） row(默认值)：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。","text":"flex-direction属性 决定主轴的方向（即项目的排列方向） row(默认值)：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性 默认情况下，项目都排在轴线上，flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-content属性 定义了项目在主轴上的对齐方式。 flex-start(默认值)：左对齐。 flex-end：右对齐。 center：居中。 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性 定义项目在交叉轴上如何对齐 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline：项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认）：轴线占满整个交叉轴。 选择单个元素 html 12345&lt;article&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/article&gt; css 123456article:first-child&#123; align-self: flex-start;&#125;article:nth-child(2)&#123; align-self:center;&#125; flex-grow属性 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis属性 定义了在分配多于空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值，则项目将占据固定空间。 flex属性 是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。 order属性 定义项目的排列顺序。数值越小，排列越靠前，默认为0 定位元素在弹性布局中的表现 绝对定位没有了空间位，flex布局会失效。 相对定位保留了空间位，flex布局仍有效果。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"转载：JS中的块级作用域，var、let、const三者的区别","slug":"转载：JS中的块级作用域，var、let、const三者的区别","date":"2019-08-22T02:08:30.000Z","updated":"2019-08-22T02:15:29.917Z","comments":true,"path":"2019/08/22/转载：JS中的块级作用域，var、let、const三者的区别/","link":"","permalink":"http://yoursite.com/2019/08/22/转载：JS中的块级作用域，var、let、const三者的区别/","excerpt":"首先，ECMAScript和JavaScript关系： ECMAScript是一个国际通过的标准化脚本语言。JavaScript由ECMAScript和DOM、BOM三者组成。可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。","text":"首先，ECMAScript和JavaScript关系： ECMAScript是一个国际通过的标准化脚本语言。JavaScript由ECMAScript和DOM、BOM三者组成。可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。 1.块作用域{ }JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。 块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &#123; var a = 1; console.log(a); // 1&#125;console.log(a); // 1// 可见，通过var定义的变量可以跨块作用域访问到。(function A() &#123; var b = 2; console.log(b); // 2&#125;)();// console.log(b); // 报错，// 可见，通过var定义的变量不能跨函数作用域访问到if(true) &#123; var c = 3;&#125;console.log(c); // 3for(var i = 0; i &lt; 4; i++) &#123; var d = 5;&#125;;console.log(i); // 4 (循环结束i已经是4，所以此处i为4)console.log(d); // 5// if语句和for语句中用var定义的变量可以在外面访问到，// 可见，if语句和for语句属于块作用域，不属于函数作用域。&#123; var a = 1; let b = 2; const c = 3; &#123; console.log(a); // 1 子作用域可以访问到父作用域的变量 console.log(b); // 2 子作用域可以访问到父作用域的变量 console.log(c); // 3 子作用域可以访问到父作用域的变量 var aa = 11; let bb = 22; const cc = 33; &#125; console.log(aa); // 11 // 可以跨块访问到子 块作用域 的变量 // console.log(bb); // 报错 bb is not defined // console.log(cc); // 报错 cc is not defined&#125;2.var、let、const的区别 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。 同一个变量只能使用一种方式声明，不然会报错 12345678910111213141516171819202122232425262728293031323334353637// 块作用域&#123; var a = 1; let b = 2; const c = 3; // c = 4; // 报错 // let a = 'a'; // 报错 注：是上面 var a = 1; 那行报错 // var b = 'b'; // 报错：本行报错 // const a = 'a1'; // 报错 注：是上面 var a = 1; 那行报错 // let c = 'c'; // 报错：本行报错 var aa; let bb; // const cc; // 报错 console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 console.log(aa); // undefined console.log(bb); // undefined&#125;console.log(a); // 1// console.log(b); // 报错// console.log(c); // 报错// 函数作用域(function A() &#123; var d = 5; let e = 6; const f = 7; console.log(d); // 5 console.log(e); // 6 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到) console.log(f); // 7 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到)&#125;)();// console.log(d); // 报错// console.log(e); // 报错// console.log(f); // 报错 ————————————————版权声明：本文为CSDN博主「hot_cool」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/hot_cool/article/details/78302673","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-08-21T03:13:37.000Z","updated":"2019-08-21T14:10:27.062Z","comments":true,"path":"2019/08/21/正则表达式/","link":"","permalink":"http://yoursite.com/2019/08/21/正则表达式/","excerpt":"正则表达式 正则表达式是国际标准，跨越语言 正则表达式是一个规则，用于验证字符串","text":"正则表达式 正则表达式是国际标准，跨越语言 正则表达式是一个规则，用于验证字符串 基础 创建正则表达式的对象 创建正则表达式的对象 12345//var 变量 = new RegExp(\"正则表达式\",\"匹配模式\")//使用typeof检查正则对象，会返回object//RegExp(\"a\")这个正则表达式可以检查一个字符串是否含有alet reg = new RegExp(\"a\",\"i\")let str = \"a\" 在构造函数中可以传递一个匹配模式作为第二个参数：可以是 i 忽略大小写 g 全局匹配模式 正则表达式的基本方法 test() 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false123let result = reg.test(str)console.log(result) //trueconsole.log(reg.test(\"bcbc\")) //false 严格区分大小写 使用字面量来创建正则表达式 语法：let 变量 = /正则表达式/匹配模式 1let reg = /a/i 创建一个正则表达式，检查一个字符串中是否有a或b 12345678let reg = /a|b/i //使用 | 表示或者的意思console.log(reg.test(\"ac\")) //true``` - 创建一个正则表达式检查一个字符串中是否有字母``` javascriptlet reg = /[a-z]/i //[]里的内容也是或的关系console.log(reg.test(\"h\")) //true 检查一个字符串中是否含有abc 或 adc 或 aec 12let reg = /a[bde]c/console.log(reg.test(\"aec\")) //true [^ ] 除了 12let reg = /[^ab]/iconsole.log(reg.test(\"abc\")) //true 除了ab还有c 支持正则表达式的String对象的方法 split()可以将一个字符串拆分为一个数组 123let str = \"1a2b3c4d5e6f7\"let result = str.split(/[A-z]/)console.log(result) //\"1,2,3,4,5,6,7\" search()可以搜索字符串中是否含有指定内容,如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1，它可以接收一个正则表达式作为参数，然后回根据正则表达式去检索字符串,不会全局匹配 12345678let str = \"hello abc hello abc\"result = str.search(\"abc\")console.log(result) //6//搜索字符串中是否含有abc 或aec 或afcstr = \"hello hello aec afc\"result = str.search(/a[bef]c/)console.log(result) //12 match()可以根据正则表达式，从一个字符串中将符合条件的内容提取出来,默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索，我们可以设置为全局匹配模式，这样就会匹配到所有的内容 123let str = \"1a2b3c4d5e6f7A8\"let result = str.match(/[a-z]/gi)console.log(result) //\"a,b,c,d,e,f,A\" replace()可以将字符串中指定内容替换为新的内容，参数：被替换的内容、新的内容，默认只会替换第一个 123let str = \"1a2a3c4d5e6f7A8\"let result = str.replace(/a/gi,\"@\")console.log(result) //\"1@2@3c4d5e6f7@8\" 语法 量词 通过变量可以设置一个内容出现的次数 量词只对它前边的一个内容起作用 {n}正好出现 n 次 {m,n} 出现 m 到 n 次 {m,} 出现 m 次以上 + 至少一个，相当于{1,} * 0个或多个，相当于{0,} ? 0个或1个，相当于{0,1} 12345678let reg = /a&#123;3&#125;/ //aaareg = /(ab)&#123;3&#125;/ //abababreg = /ab&#123;3&#125;c/ //abbbcreg = /ab&#123;1,3&#125;c/ //abc abbc abbbcreg = /ab+c/ //至少一个breg = /ab*c/ //有没有b都行reg = /ab?c/ //0个或1个b 检查一个字符串是否以a开头结尾 ^ 表示开头 1reg = /^a/ $表示结尾 1reg = /a$/ 如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式 12reg = /^a$/ reg = /^a|a$/ //以a开头或以a结尾 练习：创建一个正则表达式，用来检查一个字符串是否是一个合法手机号 手机号的规则：11位、以1开头、第二位3-9任意数字、三位以后任意数字9个 ^1 [3-9] [0-9]{9}$12345let phoneStr = \"13567890123\"let wrongStr = \"10567890123\"let phoneReg = /^1[3-9][0-9]&#123;9&#125;$/console.log(phoneReg.test(phoneStr)) //trueconsole.log(phoneReg.test(wrongStr)) //false 检查一个字符串中是否含有. . 表示任意字符 在正则表达式中使用\\作为转义字符 . 来表示 . \\ 来表示 \\ 注意：使用构造函数时，由于它的参数是一个字符串，而\\是字符串中转义字符，如果要使用\\则需要使用\\来代替 有特殊意义的字符 \\w 任意字母、数字、下划线 [A-z0-9_] \\W 除了字母、数字、下划线 [^A-z0-9_] \\d 任意数字 [0-9] \\D 除了数字 [^0-9] \\s 空格 \\S 除了空格 \\b 单词边界 （/\\bchild\\b/ 和 children） \\B 除了单词边界123//去掉开头和结尾的空格let str = \" hello world \"str = str.replace(/^\\s*|\\s$/g,\"\") 邮箱的正则 电子邮箱的格式 任意字母数字下划线 . 任意字母数字下划线 @ 任意字母数字 . 任意字母（2-5位） . 任意字母（2-5位） 正则写法: \\w{3,} (.\\w+)* @ [A-z0-9]+ (.[A-z]{2,5}){1,2} 代码 1let emailReg = /^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"js中常用的数组和字符串方法","slug":"js中数组方法","date":"2019-08-19T06:31:27.000Z","updated":"2019-08-19T08:25:39.519Z","comments":true,"path":"2019/08/19/js中数组方法/","link":"","permalink":"http://yoursite.com/2019/08/19/js中数组方法/","excerpt":"数组栈方法 push() 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。该方法会改变数组的长度。 pop() 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。该方法会改变数组的长度。","text":"数组栈方法 push() 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。该方法会改变数组的长度。 pop() 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。该方法会改变数组的长度。 队列方法 shift() 能够移除数组中的第一项并返回该项，同时将数组长度减1。该方法会改变数组的长度。 unshift() 在数组前端添加任意个项并返回新数组的长度。该方法会改变数组的长度。 重排序方法 reverse() 用于颠倒数组中元素的顺序,会改变原来的数组，而不会创建新的数组。 sort() 对数组中的元素照字符编码的顺序进行排序,数组在原数组上进行排序，不生成副本,要想按照数值大小排序，还要使用一个排序函数。 操作方法 concat() 基于当前数组中的所有项创建一个新数组。具体来说，会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。 slice() 基于当前数组中的一或多个项创建一个新数组。在只有一个参数的情况下，返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法会返回起始和结束位置之间的项（不包括结束位置的项）。slice()方法不会影响原始数组。 splice() 主要用途是向数组的中部插入项。删除：两个参数，要删除的第一项的位置和要删除的项数；插入：三个参数，起始位置、0和要插入的项；替换：三个参数，起始位置、要删除的项数和要插入的任意数量的项。splice()方法始终都会返回一个包含从原始数组中删除的项的数组（如果没删，就返回空数组）。该方法会改变原始数组。 位置方法 indexOf() 接收两个参数，要查找的项和（可选）表示查找起点位置的索引，indexOf()从数组的开头开始（位置0）往后查找.返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。 lastIndexOf() 从数组的末尾开始向前查找。 迭代方法都会对数组中的每一项运行给定函数，都不会改变原始数组。 every() 如果该函数对每一项都返回true，则返回true。 filter() 返回该函数会返回true的项组成的数组。 forEach() 这个方法没有返回值。 map() 返回每次函数调用的结果组成的数组。 some() 如果该函数对任一项返回true，则返回true。 归并方法 reduce() 接收两个参数，在每一项上调用的函数和（可选）作为归并基础的初始值。传给reduce()的函数接受四个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。 reduceRight() 从数组的最后一项开始，向前遍历到第一项。 字符串 charAt() 接收一个参数，字符在字符串中的位置，返回指定位置的字符。 concat() 方法同数组。 indexOf() 方法同数组。区分大小写。 includes() 用于判断字符串是否包含指定字串，如果找到匹配的字符串则返回true，否则返回false。 match() 在字符串内检索指定的项，或找到一个或多个（是否具有标志g）正则表达式的匹配。如果没有找到，将返回null。否则，返回一个数组。 repeat() 接收一个参数，要复制的次数。返回复制指定次数并连接在一起的新字符串。 replace() 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。返回一个新的字符串。该方法不会改变原始字符串。 search() 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回相匹配的String对象起始位置。没有找到则返回-1。 slice() 方法同数组。 split() 用于把一个字符串分割成字符串数组。split() 方法不改变原始字符串。 substr() 可在字符串中抽取从开始下标开始的指定数目的字符。参数是字串的开始位置和长度。该方法不会改变源字符串。 substring() 用于提取字符串中介于两个指定下标之间的字符。返回的子串包括开始处的字符，不包括结束处的字符。 toLowerCase() &amp; toUpperCase() 用于把字符串转换为小/大写，该方法不会改变源字符串。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"c语言快速入门(by 畅喵的瞎扯)","slug":"c语言快速入门-by-畅喵的瞎扯","date":"2019-08-18T09:01:54.000Z","updated":"2019-08-19T08:30:28.616Z","comments":true,"path":"2019/08/18/c语言快速入门-by-畅喵的瞎扯/","link":"","permalink":"http://yoursite.com/2019/08/18/c语言快速入门-by-畅喵的瞎扯/","excerpt":"给我负责的新人写快速入门，没事儿的话就更新点。 一、搭建c语言运行环境和c语言编辑器 如果你是第一次了解到编程的小白，也许你会对c语言这个名词很陌生，它是一种通用的、面向过程式的计算机程序设计语言。没懂？那你可以简单理解为利用一些字母和数字实现某种逻辑的工具，将人脑需要复杂计算出来的东西通过计算机一步就得出结果，当然这堆字母和数字肯定是没有计算功能的神通，但是通过编译这一方法就可以将你所写下的字母数字转化成计算机认识的机器语言，而c语言也是众多计算机语言中最接近机器语言的。","text":"给我负责的新人写快速入门，没事儿的话就更新点。 一、搭建c语言运行环境和c语言编辑器 如果你是第一次了解到编程的小白，也许你会对c语言这个名词很陌生，它是一种通用的、面向过程式的计算机程序设计语言。没懂？那你可以简单理解为利用一些字母和数字实现某种逻辑的工具，将人脑需要复杂计算出来的东西通过计算机一步就得出结果，当然这堆字母和数字肯定是没有计算功能的神通，但是通过编译这一方法就可以将你所写下的字母数字转化成计算机认识的机器语言，而c语言也是众多计算机语言中最接近机器语言的。 想要自己写一段c语言程序，就需要一个像模像样的编辑器，这里推荐code blocks(学校的课程与考试都是用的cb)，你可以在codeblocks官网上下载(mingw是c语言的运行环境，也要一同下载哦)，如果选择的压缩包版的解压即可，安装版的直接装就好了。下图给出了供参考的下载项。 打开code blocks之后可能会提示一些关于environment即环境的问题，这大概率是需要添加c语言的环境变量，这一步自行百度就可以了(一点提示：把c语言源文件夹下的bin添加到我的电脑高级设置中环境变量的path)，如果始终无法解决环境变量的问题，就用w3c或者菜鸟教程的在线编辑器吧，手机中也可以下载c语言的编辑器app，如果仅仅是为了练习代码，甚至用手机记事本都可以。 二、我的第一个c语言程序 每接触一种新的语言肯定要先敲hello world啦。打开codeblocks之后，点击左上角的【file】 -&gt; 【New】 -&gt; 【File】 选择c/c++ source，然后选择c语言，在创建的页面中填好路径与名称（下面Add file..那个不用选），点击【finish】就可以了，下面给出了hello world的示例代码12345678#include&lt;stdio.h&gt;int main()&#123; /* 这是两 段注释 */ printf(\"hello world\"); //另一种注释方式 return 0;&#125; 敲完之后，在菜单栏里找到【build】，选择【build and run】，几秒之后，就可以看到突然蹦出来了一个命令提示框，显示着你刚才敲的hello world 现在我们来分析下这几行代码：第一行的代码叫做头文件，就是写在一个c语言程序最前面的地方咯。stdio.h是c语言的库，库就好比工具箱，里面有很多实现各种功能的工具。include，正如它的释义“包含”一样， 这一行代码翻译过来就是：“这个程序包含了c语言的库”，所以在接下来引用c语言库里的工具或方法就合乎情理了。 第二行是程序的主函数，main即凸显出一个主要的感觉，所有的代码都从主函数开始执行，正因为里面的代码和主函数是包含的关系，所以下面用一个大括号把要执行的代码包裹起来，为了视觉效果上更能展示出包含的关系，括号内部的代码要空四个格。 代码的内容里是没有中文的(包括双引号、括号、分号都是英文的)，但是可以写中文的注释，就是字面意思，对于同一个问题一万个人有一万种代码的写法，为了让别人清楚你的代码干了些什么，有什么要注意的地方，都可以写成注释，/**/就像括号一样，里面的内容都是注释；//的话只能注释一行，从上面的例子就可以看出来 hello world是怎么被显示出来的呢？就是靠着库函数printf。库函数相当于头文件中stdio.h这一工具箱里面的工具(现在清楚头文件的作用了吧),正因为你引入了c语言的头文件，才能在这里使用它的库函数。printf中有单词print“打印”，顾名思义，就是把printf中所包含的内容打印显示在命令提示框中。 return的中文含义是“返回”，0即为空，结束的意思，连接起来就是“回归虚无”(听上去好修仙的感觉)的意思，这也说明了这个程序走到了终点，代码到这里也就结束了。现在是不是对c语言有了一丝丝了解呢，可以试着去敲一个这样的小程序，输出不同的内容哈。 (持续更新中，敬请期待)","categories":[{"name":"cs课程","slug":"cs课程","permalink":"http://yoursite.com/categories/cs课程/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://yoursite.com/tags/c语言/"}]},{"title":"关于如何搭建自己的hexo博客","slug":"关于如何搭建自己的hexo博客","date":"2019-08-15T03:36:04.000Z","updated":"2019-08-16T12:03:24.756Z","comments":true,"path":"2019/08/15/关于如何搭建自己的hexo博客/","link":"","permalink":"http://yoursite.com/2019/08/15/关于如何搭建自己的hexo博客/","excerpt":"一、环境准备 下载node.js(在官网下载就可以了，之后无脑点击下一步安装，安装好之后可以在cmd( win键 + R 打开运行，在里面输入cmd就可以进入cmd了 )里输入: node –version 检查版本，有版本就说明安装好了，在下载node的时候也会绑定下载npm，用同样的方法在cmd里输入: npm –version 看下npm装上了没有) npm上下载的资源比较慢，所以我们用国内的淘宝镜像cnpm，用npm安装cnpm: npm install -g cnpm –registry=https://registry.npm.taobao.org (记得cnpm -v检查下版本哦)","text":"一、环境准备 下载node.js(在官网下载就可以了，之后无脑点击下一步安装，安装好之后可以在cmd( win键 + R 打开运行，在里面输入cmd就可以进入cmd了 )里输入: node –version 检查版本，有版本就说明安装好了，在下载node的时候也会绑定下载npm，用同样的方法在cmd里输入: npm –version 看下npm装上了没有) npm上下载的资源比较慢，所以我们用国内的淘宝镜像cnpm，用npm安装cnpm: npm install -g cnpm –registry=https://registry.npm.taobao.org (记得cnpm -v检查下版本哦) 下载Git，同样是在官网下载，下载安装完成后(记得安装的路径)在桌面一空白区域右键，看下是否出现了两个Git GUI 和 Git Bash的选项，如果有的话在cmd中输入: git –version ，查看一下版本号，可能这里cmd提示说找不到git这个命令，这就表明需要添加环境变量，具体操作自行百度，非常简单，path里加一个路径即可 安装hexo: cnpm install -g hexo-cli (hexo -v检查版本) 二、创建博客 创建一个文件夹存放博客的所有资源,可以在cmd里直接创建，或者去到某个文件夹里新建文件夹都是可以的(我这里直接在默认的我的文档下创建了一个叫blog的文件夹) 1C:\\Users\\23163&gt;mkdir blog 在cmd中移动到你这个新建文件夹中(我这里直接cd blog就可以了) 初始化hexo，看到终端提示：INFO Start blogging with Hexo! 就说明初始化成功了 1C:\\Users\\23163\\blog&gt;hexo init 在cmd中执行命令: hexo s (hexo serve的简写形式)，就可以在本地服务器运行你的hexo博客了，会给一个默认的端口( INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. )，想要退出的话，就像它提示的那样在终端输入Ctrl+C就可以了 在cmd中执行命令: hexo n “我的第一篇博客文章” (hexo new “XXX”的简写形式)，就会为你创建一篇新的博客了，博客的格式为markdown，你可以通过vim或者vscode都可以对博客的内容进行操作 在cmd中执行命令: hexo clean 这一步是清除原有的静态文件(当你更新了配置、主题、内容有可能无法显示，直接清除原有的静态文件再创建新的静态文件是稳妥的方法) 在cmd中执行命令: hexo g (hexo generate的简写形式)，生成包括html、css、js、图片等各种静态文件 再次执行 hexo s 命令，就可以看到刚刚创建的文章被添加到博客里了 三、部署博客到Github 退出刚才在运行的本地博客，在cmd中执行命令,安装部署的工具(记得还是在之前新建的blog文件夹下) 1C:\\Users\\23163\\blog&gt;cnpm install --save hexo-deployer-git 需要你拥有一个GitHub账号，登录你的GitHub，创建一个仓库【create a new repository】，仓库名的格式为：Owner.github.io 其中Owner是你GitHub的名字，这里一定要用这个名字才可以，描述随便写就可以了，创建好仓库后，记录下它的https地址 打开blog文件夹中的_config.yml文件，移动到该文件内容的最底端#Depolyment部分，加上配置，这里的rope换成你自己刚才设置的地址就可以(敲代码的时候注意缩进为两格，冒号后面需要一个空格) 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/MrPand111/MrPand111.github.io.git branch: master 返回到cmd,执行命令: hexo d (hexo deploy的简写形式)，中途需要你登录GitHub账户，登录一下就可以，如果遇到了 Error: Spawn failed，应该是你之前没有在git配置过信息导致的，在cmd中执行: git config –global user.email “you@example.com“ 和 git config –global user.name “Your Name” (双引号里输入你的GitHub信息就行)，然后再次hexo d估计就没问题了 到这里你就可以通过刚才设置的 Owner.github.io 来访问自己的博客了，这里拿我的博客作为示范: https://mrpand111.github.io/ 欢迎大家一起来讨论和深入研究hexo鸭！","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"JS实现一个简单的计算器","slug":"我的第一篇博客文章","date":"2019-08-15T01:15:04.000Z","updated":"2019-08-16T12:53:37.128Z","comments":true,"path":"2019/08/15/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2019/08/15/我的第一篇博客文章/","excerpt":"Part1 HTML + CSShtml部分的话非常简单，利用表格就可以完成,值得一提的就是显示框这里虽然用的是input，但是要加一个只读属性","text":"Part1 HTML + CSShtml部分的话非常简单，利用表格就可以完成,值得一提的就是显示框这里虽然用的是input，但是要加一个只读属性 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id=\"counter\"&gt; &lt;div class=\"counter_window\"&gt;&lt;input type=\"text\" id=\"counter_window\" readonly=\"readonly\"&gt;&lt;/div&gt; &lt;table id=\"table1\"&gt; &lt;tr&gt; &lt;td&gt;7&lt;/td&gt; &lt;td&gt;8&lt;/td&gt; &lt;td&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;.&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td style=\"font-weight: normal;font-size: 14px;\"&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table id=\"table2\"&gt; &lt;tr&gt;&lt;td&gt;/&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;x&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;+&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=\"background: rgb(255, 214, 80); color: white;\"&gt;=&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt; css也是用一些基本的把大小位置固定就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#counter&#123; width:300px; height:507px; border: 1px solid black; margin:100px auto;&#125;.counter_window&#123; width:300px; height:100px; text-align: center;&#125;#counter_window&#123; width:295px; height:100px; text-align: right; font-size: 20px;&#125;#table1&#123; width:215px; height:400px; margin-top:7px; margin-left:10px; float:left;&#125;#table1 td&#123; width:68px;&#125;#table2&#123; width:75px; height:400px; margin-top:7px; float:left; background:#eee;&#125;td&#123; text-align: center; font-size: 18px; cursor: pointer; font-weight: bold;&#125;td:hover&#123; background: skyblue;&#125; Part2 JSjs这里我选择了一个比较投机的方法，eval函数，将字符串转换成js可以看懂的式子计算出来并返回结果，这个函数可以说是双刃剑，优点在于快速方便的解析字符串，缺点就是可以解析一些恶意的代码 1234567891011121314151617181920212223242526//获取视窗const cWindow = document.getElementById('counter_window')//定义要计算的字符串和计算的结果let allStr = \"\"let result//将键入的数字添加到待计算的字符串中function Add(num)&#123; allStr =allStr + num cWindow.value = allStr&#125;//计算字符串function Computed()&#123; result = String(eval(allStr)) allStr = Number(result) cWindow.value = allStr&#125;//Del删除字符串function Del()&#123; allStr = String(cWindow.value).slice(0,allStr.length-1) console.log(allStr) cWindow.value = allStr&#125; Part3 完整代码完成了这个计算器后，应该就对js自定义函数的应用有了一点了解吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;简单计算器&lt;/title&gt; &lt;style&gt; #counter&#123; width:300px; height:507px; border: 1px solid black; margin:100px auto; &#125; .counter_window&#123; width:300px; height:100px; text-align: center; &#125; #counter_window&#123; width:295px; height:100px; text-align: right; font-size: 20px; &#125; #table1&#123; width:215px; height:400px; margin-top:7px; margin-left:10px; float:left; &#125; #table1 td&#123; width:68px; &#125; #table2&#123; width:75px; height:400px; margin-top:7px; float:left; background:#eee; &#125; td&#123; text-align: center; font-size: 18px; cursor: pointer; font-weight: bold; &#125; td:hover&#123; background: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"counter\"&gt; &lt;div class=\"counter_window\"&gt;&lt;input type=\"text\" id=\"counter_window\" readonly=\"readonly\"&gt;&lt;/div&gt; &lt;table id=\"table1\"&gt; &lt;tr&gt; &lt;td onclick=\"Add('7')\"&gt;7&lt;/td&gt; &lt;td onclick=\"Add('8')\"&gt;8&lt;/td&gt; &lt;td onclick=\"Add('9')\"&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=\"Add('4')\"&gt;4&lt;/td&gt; &lt;td onclick=\"Add('5')\"&gt;5&lt;/td&gt; &lt;td onclick=\"Add('6')\"&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=\"Add('1')\"&gt;1&lt;/td&gt; &lt;td onclick=\"Add('2')\"&gt;2&lt;/td&gt; &lt;td onclick=\"Add('3')\"&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=\"Add('.')\"&gt;.&lt;/td&gt; &lt;td onclick=\"Add('0')\"&gt;0&lt;/td&gt; &lt;td onclick=\"Del()\" style=\"font-weight: normal;font-size: 14px;\"&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table id=\"table2\"&gt; &lt;tr&gt;&lt;td onclick=\"Add('/')\"&gt;/&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td onclick=\"Add('*')\"&gt;x&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td onclick=\"Add('-')\"&gt;-&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td onclick=\"Add('+')\"&gt;+&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=\"background: rgb(255, 214, 80); color: white;\" onclick=\"Computed()\"&gt;=&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const cWindow = document.getElementById('counter_window') let allStr = \"\" let result function Add(num)&#123; allStr =allStr + num cWindow.value = allStr &#125; function Computed()&#123; result = String(eval(allStr)) if(result.length === 18)&#123; result = result.slice(0,17) &#125; allStr = Number(result) cWindow.value = allStr &#125; function Del()&#123; allStr = String(cWindow.value).slice(0,allStr.length-1) console.log(allStr) cWindow.value = allStr &#125;&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]}]}