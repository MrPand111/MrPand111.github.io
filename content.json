{"meta":{"title":"畅喵の博客","subtitle":"请叫我熊猫大人！","description":"华中农业大学的计科菜鸡，大前端研习ing","author":"MrPanda刘畅","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-08-15T08:49:44.000Z","updated":"2019-08-15T08:50:41.856Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-15T08:50:12.000Z","updated":"2019-08-15T08:51:10.688Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"MVC和MVVM区别及原理","slug":"MVC和MVVM区别及原理","date":"2019-12-11T14:22:50.000Z","updated":"2019-12-11T16:24:29.318Z","comments":true,"path":"2019/12/11/MVC和MVVM区别及原理/","link":"","permalink":"http://yoursite.com/2019/12/11/MVC和MVVM区别及原理/","excerpt":"简述 MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来","text":"简述 MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来 传统的MVC123456789&lt;body&gt; &lt;input type=\"text\" id=\"input\" value=123&gt; &lt;div id=\"view\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const input = document.getElementById('input') const view = document.getElementById('view') view.innerHTML = input.value &lt;/script&gt; 运行上面的代码你会发现在div中文本和input框中的相同，但是改变input中的数值后，div却不会跟着变化 12345678910111213&lt;body&gt; &lt;input type=\"text\" id=\"input\" value=123&gt; &lt;button id=\"button\" @click=\"change\"&gt;改变&lt;/button&gt; &lt;div id=\"view\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const input = document.getElementById('input') const view = document.getElementById('view') const button = document.getElementById('button') button.onclick = function() &#123; view.innerHTML = input.value &#125; &lt;/script&gt; 这一次呢？每次点击按钮，div中的内容就会跟着变化。但局限性也在这里，怎么样才能实时获取这个input的变化并反应到div中呢？正巧，vue中就可以实现这个难题 vue中MVVM123456789101112131415161718192021&lt;template&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" id=\"input\" v-model=\"val\"&gt; &lt;button id=\"button\" @click=\"change\"&gt;改变&lt;/button&gt; &lt;div id=\"view\"&gt;&#123;&#123;val&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; val: '' &#125; &#125;, methods: &#123; change() &#123; this.val -= 2 &#125; &#125; &#125;&lt;/script&gt; 学过vue的同学一定能看懂这一段代码，在input框输入的数字可以实时显示在div中，当执行change函数后，不管是input中还是div中的数字都跟着改变，正是因为它们都与一个叫val的data绑定在一起，接下来就和畅喵一起看看什么是mvc和MVVM吧。 定义MVC 是Model-View-Controller的简写。 Model：模型对象负责在数据库中存取数据。 View：视图是依据模型数据创建的。像前端的HTML和Java、Python中的GUI Controller： 控制器，也就是我们常说的业务逻辑代码，负责从View读取数据，发送到Model 举一例： 注册账号时页面上的两个输入框和一个按钮属于【View】 点击按钮触发的方法以及将【View】中input的value传给【Model】的是【Controller】 将accounts和password存入数据库的是【Model】 MVVM 是Model-View-ViewModel的简写。【模型】指的是后端传递的数据。【视图】指的是所看到的页面。 【视图模型】是mvvm的核心，它是连接view和model层的桥梁。它有两个方向： 将【模型】转化成【视图】（数据转化成页面） 将【视图】转化成【模型】（页面内容转化成后台的数据） 实现的方式是：DOM事件监听。这两个方向都实现的，我们称之为数据的双向绑定。 在MVVM框架下视图和模型是不能直接通信的。它们通过VM来通信，当数据发生变化，VM能够监听到数据的这种变化，然后通知到对应的视图做自动更新，反之如此。 原理观察者（订阅者）模式 - 数据劫持 Observer是vue中的数据监听器，把一个普通对象传给Vue实例中的data时，会遍历此对象转化成setter、getter 当检测到数据访问或者改变时，就会触发Object.defineProperty，通知变化给Dep(依赖) 在Observer监听的同时，Compile会对每个元素节点解析指令，替换函数模板，绑定更新函数，通过watch初始化相应的订阅 watch是沟通Observer和Compile的桥梁，能够为Dep添加订阅并且收到Dep每个属性变动的通知，更新视图 简单模拟js实现变化监测123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;input type=\"text\" id=\"input\" value='' oninput=\"Observe(this.value)\"&gt; &lt;button id=\"button\"&gt;改变&lt;/button&gt; &lt;div id=\"view\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const input = document.getElementById('input') const view = document.getElementById('view') const button = document.getElementById('button') let data = &#123;&#125; let _val function Observe(value) &#123; data.val = value &#125; function compile(val) &#123; input.value = val view.innerHTML = val &#125; button.onclick = function() &#123; data.val -= 2 &#125; Object.defineProperty(data,'val',&#123; set: function(newVal) &#123; _val = newVal compile(data.val) &#125;, get: function() &#123; return _val &#125; &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"JS设计模式(三)——闭包和高阶函数","slug":"JS设计模式-三-——闭包和高阶函数","date":"2019-12-03T06:31:13.000Z","updated":"2019-12-08T12:34:36.391Z","comments":true,"path":"2019/12/03/JS设计模式-三-——闭包和高阶函数/","link":"","permalink":"http://yoursite.com/2019/12/03/JS设计模式-三-——闭包和高阶函数/","excerpt":"在JavaScript版本的设计模式中，许多模式都可以用闭包和高阶函数来实现。","text":"在JavaScript版本的设计模式中，许多模式都可以用闭包和高阶函数来实现。 闭包变量的作用域 变量的作用域，就是指变量的有效范围。 在JavaScript中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。 变量的生存周期 对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。 而对于在函数内用var关键字声明的局部变量来说，当退出函数时，这些局部变量即失去它们的价值，它们都会随着函数调用的结束而销毁。 123456789101112var func = function() &#123; var a = 1 return function() &#123; a++ alert(a) &#125;&#125;var f = func()f() // 2f() // 3f() // 4f() // 5 当执行var f = func()时，f返回了一个匿名函数的引用，它可以访问到func被调用时产生的环境，而局部变量a一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。 12345678// 循环div绑定onclick事件for(var i = 0;len = nodes.length; i &lt; len; i++) &#123; (function(i) &#123; nodes[i].onclick = function() &#123; console.log(i) &#125; &#125;)(i)&#125; 闭包的更多作用 封装变量：闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。 1234567891011121314151617// 计算乘积的函数var mult = (function() &#123; var cache = &#123;&#125; var calculate = function() &#123; var a = 1 for(var i=0;l=arguments.length;i&lt;l;i++) &#123; a = a * arguments[i] &#125; &#125; return function() &#123; var args = Array.prototype.join.call(arguments,',') if(args in cache) &#123; return cache[args] &#125; return cache[args] = calculate.apply(null,arguments) &#125;&#125;) 延续局部变量的寿命 12345678910// img对象经常用于进行数据上报// 把img变量用闭包封装起来，便能解决请求丢失的问题var report = (function() &#123; var imgs = [] return function(src) &#123; var img = new Image() imps.push(img) img.src = src &#125;&#125;)() 闭包和面向对象设计对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。 用闭包实现命令模式123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;button id=\"excute\"&gt;点我&lt;/button&gt; &lt;button id=\"undo\"&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var Tv = &#123; open: function() &#123; console.log('打开电视机') &#125;, close:function() &#123; console.log('关上电视机') &#125; &#125; var createCommand = function(receiver) &#123; var excute = function() &#123; return receiver.open() // 执行命令，打开电视机 &#125; var undo = function() &#123; return receiver.close() &#125; return &#123; excute: excute, undo: undo &#125; &#125; var setCommand = function(command) &#123; document.getElementById('execute').onclick = function() &#123; command.excute() // 打开电视机 &#125; document.getElementById('undo').onclick = function() &#123; command.undo() // 关闭电视机 &#125; &#125; setCommand(createCommand(Tv))&lt;/script&gt; 闭包和内存管理 使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包和全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为null。 高阶函数高阶函数是指至少满足下列条件之一的函数： 函数可以作为参数被传递 函数可以作为返回值输出 函数作为参数传递 回调函数 123456789101112131415// 创建100个div节点var appendDiv = function(callback) &#123; for(var i=0;i&lt;100;i++) &#123; var div = document.createElement('div') div.innerHTML = i document.body.appendChild(div) if(typeof callback === 'function') &#123; callback(div) &#125; &#125;&#125;// 隐藏节点作为回调函数，在节点创建完成后执行appendDiv(function(node) &#123; node.style.display = 'none'&#125;) 函数作为返回值输出 让函数继续返回一个可执行的函数，意味着运算过程是可延续的。 12345678910111213141516var getSingle = function(fn) &#123; var ret // 利用闭包保存ret一值在作用域中 return function() &#123; console.log(ret) console.log(arguments) //callee:f() console.log(this) // window return ret || (ret = fn.apply(this,arguments)) &#125;&#125;var getScript = getSingle(function() &#123; return document.createElement('script')&#125;)var script1 = getScript()var script2 = getScript()alert(script1 === script2) // true 高阶函数实现AOPAOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来。 123456789101112131415161718192021222324252627Function.prototype.before = function(beforefn) &#123; var _self = this // 保存原函数的引用 return function() &#123; // 返回包含了原函数和新函数的“代理函数” beforefn.apply(this,arguments) // 执行新函数，修正this return _self.apply(this,arguments) // 执行原函数 &#125;&#125;Function.prototype.after = function(afterfn) &#123; var _self = this return function() &#123; var ret = _self.apply(this,arguments) afterfn.apply(this,arguments) return ret &#125;&#125;var func = function() &#123; console.log(2)&#125;func = func.before(function()&#123; console.log(1)&#125;).after(function()&#123; console.log(3)&#125;)func()// 1// 2// 3 高阶函数的其他应用 currying currying又称部分求值。一个currying的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。 1234567891011121314151617181920212223242526var currying = function(fn) &#123; var args = [] return function() &#123; // 如果没有参数就是执行函数 if(arguments.length===0) &#123; return fn.apply(this,args) &#125; else &#123; // 有参数就继续存到闭包的数组中 [].push.apply(args,arguments) return arguments.callee // 返回这个匿名函数 &#125; &#125;&#125;var cost = (function() &#123; var money = 0 return function() &#123; for(var i=0;l=arguments.length;i&lt;l;i++) &#123; money += arguments[i] &#125; return money &#125;&#125;)()var cost = currying(cost) // 转化成currying函数cost(100)cost(200)cost(300)alert(cost()) // 600 uncurrying call和apply可以让对象去借用一个不属于它的方法。通过uncurrying可以把Array.prototype中泛化的this提取出来。下面的例子中，就把Array.prototype.push.call变成了一个通用的push函数。这样一来，push函数的作用就跟Array.prototype.push一样了。 12345678910111213141516Function.prototype.uncurrying = function() &#123; var self = this //push函数 return function() &#123; console.log(arguments) // put函数的arguments var obj = Array.prototype.shift.call(arguments); return self.apply(obj,arguments) // self应该Array.prototype.push obj是下面立即执行函数的的123 arguments是4 &#125;&#125;var put = Array.prototype.push.uncurrying(); // 如果下面的IIFE是这样的格式；前面一个语句要加分号// IILE可以用+ ！ void 声明(function() &#123; put(arguments,4) console.log(arguments)&#125;)(1,2,3) 函数节流 在很少情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能被非常频繁的调用，而造成大的性能问题。 函数被频繁调用的场景 window.onresize事件 mouseover事件 上传进度 函数节流原理 上面三个场景共同问题是函数被触发的频率太高 可以通过seTimeout来完成 12345678910111213141516171819202122232425var throttle = function(fn,interval) &#123; var __self = fn, // 保存需要被延迟执行的函数引用 timer, // 定时器 firstTime = true // 是否第一次调用 return function() &#123; var args = arguments, __me = this if(firstTime) &#123; // 如果第一次调用，不需要延迟执行 __self.aaply(__me,args) return firstTime = false &#125; if(timer) &#123; // 如果是第一次调用，不需要延迟 return false &#125; timer = setTimeout(function() &#123; clearTimeout(timer) timer = null __self.apply(__me,args) &#125;,interval || 500) &#125;&#125;window.onresize = throttle(function() &#123; console.log(1)&#125;,500) 分时函数 在短时间内往页面中大量添加DOM节点显然也会让浏览器吃不消，我们看到的结果往往就是浏览器的卡顿甚至假死。 123456789101112131415161718var timeChunk = function(ary,fn,count) &#123; var obj,t var len = ary.length var start = function() &#123; for(var i=0;i&lt;Math.min(count||1,ary.length);i++) &#123; var obj = ary.shift() fn(obj) &#125; &#125; return function() &#123; t = setInterval(function() &#123; if(ary.length === 0) &#123; // 如果全部节点都已经被创建好 return clearInterval(t) &#125; start() &#125;,200) // 分批执行的时间间隔 &#125;&#125; 惰性加载函数 123456789101112var addEvent = function(elem,type,handler) &#123; if(window.addEventListener) &#123; addEvent = function(elem,type,handler) &#123; elem.addEventListener(type,handler,false) &#125; &#125; else if(window.attachEvent) &#123; addEvent = function(elem,type,handler) &#123; elem.attachEvent('on'+type,handler) &#125; &#125; addEvent(elem,type,handler)&#125;","categories":[{"name":"JS设计模式系列","slug":"JS设计模式系列","permalink":"http://yoursite.com/categories/JS设计模式系列/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"配置Webpack","slug":"配置Webpack","date":"2019-11-30T02:49:05.000Z","updated":"2019-11-30T02:52:07.500Z","comments":true,"path":"2019/11/30/配置Webpack/","link":"","permalink":"http://yoursite.com/2019/11/30/配置Webpack/","excerpt":"学习Webpack主要是看dell lee的视频，后续也会看一些文档和博客，分析下webpack打包后源码","text":"学习Webpack主要是看dell lee的视频，后续也会看一些文档和博客，分析下webpack打包后源码 Webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')const CleanWebpackPlugin = require('clean-webpack-plugin')const webpack = require('webpack')module.exports = &#123; //production模式下配置项更少 mode: 'development', // source-map 是一个映射关系，会找到对应文件中的报错 // inline 直接打包到main.js中 // cheap build速度加快，查错只会精确到行，只会管业务代码 // module 还管第三方模块的查错 // eval 执行效率最快，但是提供并不全面 /* development devtool: 'cheap-module-eval-source-map',*/ /*production*/ devtool: 'cheap-module-source-map', entry: &#123; main: './src/index.js' &#125;, // 在package.json下的scripts里面加入\"start\":\"webpack-dev-server\" devServer: &#123; // 源码被变更后自动刷新整个页面 // 配置devServer、Http服务器的的文件根目录 contentBase: './dist', // open 自动打开浏览器，自动访问服务器地址localhost:8080 open: true, proxy: &#123; //配置代理，处理本地跨域 '/api': 'http://localhost:3000' &#125;, hot: true, // 开启热模块HMR(不刷新整个页面的情况下通过新模块替换老模块预览) hotOnly: true &#125;, module: &#123; rules: [&#123; test: /\\.(jpg|png|gif)$/, //匹配打包的文件 use: &#123; loader: 'url-loader', options: &#123; //placeholder 占位符 name: '[name]_[hash].[ext]', //打包的名称 outputPath: 'images/', //打包的路径 limit: 2048 //url-loader图片转化的限制 &#125; &#125; &#125;,&#123; test: /\\.scss$/, use: [&#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; importLoaders: 2, //让import引用的.scss文件也能执行postcss-loader和sass-loader //modules: true //开启css的模块打包 &#125; &#125;, &#123; loader: 'sass-loader' &#125;, &#123; loader: 'postcss-loader' //添加厂商前缀 兼容性 &#125;] //执行顺序从右到左 从下到上 &#125;,&#123; test: /\\.(eot|ttf|svg|woff)$/, //打包字体文件 use: &#123; loader: 'file-loader' &#125; &#125;,&#123; test: /\\.js$/, //用babel-loader把es6转化成es5 use: &#123; exclude: /node_modules/, // 忽略node_modules loader: 'babel-loader', //babel-loader只是webpack和babel通信的桥梁 options: &#123; presets: [ //插件的集合 ['@babel/preset-env', &#123; // 包含了所有es6转义成es5的规则 targets: &#123; chrome: \"67\" &#125;, 'useBuiltIns': 'usage' // 根据业务代码填充es6转换规则 &#125;] ], plugins: [ ['@babel/plugin-transform-runtime', &#123; // 不存在全局污染 \"corejs\": 2, \"helpers\": true, \"regenerator\": true, \"useESModules\": false &#125;] ] &#125; &#125; &#125;] &#125;, //plugin 可以在webpack运行到某个时刻的时候，帮你做一些事情（类似于vue的生命周期函数） plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' // htmlWebpackPlugin 会在打包结束后，自动生成一个html文件，并把打包生成的文件自动引入到这个html中 &#125;), new CleanWebpackPlugin(['dist'],&#123; root: path.resolve(__dirname,'../') //清除时的根目录会默认为上一层目录 &#125;), new webpack.HotModuleReplacementPlugin() // 修改代码后不会刷新页面，只会替换效果 ], //打包之前，删除dist下的所有内容 optimization: &#123; //使用tree shaking 仅dev环境需要配置 // tree shaking 只支持ES Module // package.json中配置 \"sideEffects\" 忽略某些文件 usedExports: true, // 代码分割 code solitting 和webpack无关 // 同步代码 splitChunks: &#123; chunks: 'all' &#125; // 异步代码（import）无需做任何配置，会自动进行代码分割 &#125;, output: &#123; /* publicPath: 'http://cd.com.cn', */ //如果是服务器里的静态文件 publicPath: '/', //打包生成的文件添加一个根路径 filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"JS设计模式(二)——this、calle和apply","slug":"JS设计模式-二-——this、calle和apply","date":"2019-11-29T07:57:04.000Z","updated":"2019-11-29T13:28:01.715Z","comments":true,"path":"2019/11/29/JS设计模式-二-——this、calle和apply/","link":"","permalink":"http://yoursite.com/2019/11/29/JS设计模式-二-——this、calle和apply/","excerpt":"thisJavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。","text":"thisJavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this的指向 作为对象的方法调用：this指向该对象 12345678var obj = &#123; a: 1, getA: function() &#123; alert( this === obj ) // true alert(this.a) // 1 &#125;&#125;obj.getA() 作为普通函数调用时：此时的this总是指向全局变量，在浏览器的JavaScript里，这个全局对象是window对象。 123456789window.name = 'globalName'var myObject = &#123; name: 'sven', getName: function() &#123; return this.name &#125;&#125;var getName = myObject.getNameconsole.log(getName()) // gobalName 在div节点的事件函数内部，有一个局部的callback方法，callback被作为普通函数调用时，callback内部的this指向了window，但我们往往是想让它指向该div节点 123456document.getElementById('div1').onclick = function() &#123; var that = this var callback = function() &#123; alert(that.id) // div1 &#125;&#125; JavaScript中没有类，但是可以从构造器中创建对象，同时也提供了new运算符，使得构造器看起来更像一个类。除了宿主提供的一些内置函数，大部分JavaScript函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用new运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的this就指向返回的这个对象。 1234567891011121314var MyClass = function() &#123; this.name = 'sven'&#125;var obj = new MyClass()alert(obj.name) // svenvar MyClass = function() &#123; this.name = 'sven' return &#123; name: 'anne' &#125;&#125;var obj = new MyClass()alert(obj.name) // anne 用getId来代替getElementById 12345678document.getElementById = (function(func)&#123; return function() &#123; return func.apply(document,arguments) &#125;&#125;)(document.getElementById)var getId = document.getElementByIdvar div = getId('div1')alert(div.id) // div1 call和applycall和apply的区别 apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组。 call传入的参数数量不固定，跟apply相同的是，第一个参数也是代表函数体内的this指向，从第二个参数开始往后，每个参数被依次传入函数。 JavaScript的参数在内部就是一个数组来表示。 第一个参数为null，函数体内的this会指向默认的宿主对象。在浏览器则是window call和apply的用途 改变this的指向 1234567891011121314151617var obj1 = &#123; name: 'sven'&#125;var obj2 = &#123; name: 'anne'&#125;window.name = 'window'var getName = function() &#123; alert(this.name)&#125;getName() // windowgetName.call(obj1) // svengetName.call(obj2) // anne Function.prototype.bind 12345678910111213141516171819202122232425262728Function.prototype.bind = function(context) &#123; var self = this // 保存原函数 return function() &#123; // 返回一个新函数 return self.apply(context,arguments) // 执行新的函数的时候，会把之前传入的context当作新函数体内的this &#125;&#125;var obj = &#123; name: 'sven'func&#125;var func = function() &#123; alert(this.name)&#125;.bind(this.name)func() // sven// 完全版Function.prototype.bind = function() &#123; var self = this, context = [].shift.call(arguments), // 需要绑定的this上下文 args = [].slice.call(arguments) // 剩下的参数转成数组 return function() &#123; return self.apply(context,[].concat.call(args,[].silce.call(arguments))) // 执行新的函数的时候，会把之前传入的contenxt当作新函数体内的this // 并且组合两次分别传入的参数，作为新的参数 &#125;&#125; 借用其他对象的方法 借用构造函数 1234567891011121314var A = function(name) &#123; this.name = name&#125;var B = function() &#123; A.apply(this,arguments)&#125;B.prototype.getName = function() &#123; return this.name&#125;var B = new B('sven')console.log(b.getName()) // sven Array.prototype对象借用方法 123456789function Arraypush() &#123; var n = TO_UNIT32(this.length) // 被push的对象的length var m = %_Argumentslength() // push的参数个数 for(var i=0;i&lt;m;i++) &#123; this[i+n] = %_Arguments(i) // 复制元素 &#125; this.length = n + m // 修正length属性的值 return this.length&#125;","categories":[{"name":"JS设计模式系列","slug":"JS设计模式系列","permalink":"http://yoursite.com/categories/JS设计模式系列/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"《高性能网站建设指南》","slug":"《高性能网站建设指南》","date":"2019-11-23T05:55:49.000Z","updated":"2019-11-23T07:16:42.677Z","comments":true,"path":"2019/11/23/《高性能网站建设指南》/","link":"","permalink":"http://yoursite.com/2019/11/23/《高性能网站建设指南》/","excerpt":"","text":"补充内容什么是http？ http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASICII码形式给出。 HTTP是基于客户/服务器模式，且面向连接的。典型的HTTP事物处理有如下的过程： 客户与服务器建立连接 客户向服务器提出请求 服务器接受请求，并根据请求返回相应的文件作为应答 客户与服务器关闭连接 http请求消息一个http请求代表客户端浏览器向服务器发送的数据。一个完整的http请求，包含一个请求行，若干个消息头（请求头），换行，实体内容 请求行：描述客户端的请求方式、请求资源的名称、http协议的版本号。例如：GET/BOOK/JAVA.HTML HTTP/1.1 请求头包含： Accept：用于告诉服务器，客户端支持的数据类型 Accept-Charset：用于告诉服务器，客户端采用的编码格式 Accept-Encoding：用于告诉服务器，客户端支持的数据压缩格式 Accept-Language：客户端语言环境 Host：客户端通过这个服务器，想访问的主机名 If-Modified-Since：客户端通过这个头告诉服务器，资源的缓存时间 Referer：客户端通过这个头告诉服务器，客户端是从哪个资源来访问服务器的（防盗链） User-Agent：客户端通过这个头告诉服务器，客户端的软件环境（操作系统、浏览器版本等） Cookie：客户端通过这个头，将Cookie信息带给服务器 Connection：告诉服务器，请求完成后，是否保持连接 Date：告诉服务器，当前请求时间 实体内容： 就是指浏览器端通过htt协议发送给服务器的实体数据。例如：name=dylan&amp;id=110(get请求通过url传给服务器的数据，post请求时通过表单发送给服务器的值) 响应头包含： Location：这个头配合302状态码，用于告诉客户端找谁 Server：服务器通过这个头，告诉浏览器服务器的类型 Content-Encoding：告诉浏览器，服务器的数据压缩格式 Content-Length：告诉浏览器，返回数据的长度 Content-Type：告诉浏览器，返回数据的类型 Last-Modified：告诉浏览器当前资源缓存时间 Refresh：告诉浏览器，隔多长时间刷新 Content-Disposition: 告诉浏览器以下载的方式打开数据（例如图片） Transfer-Encoding：告诉浏览器，传送数据的编码格式 Etag：缓存相关的头（做到实时更新） Expries：告诉浏览器返回的资源缓存多长时间 Cache-Control：控制浏览器不要缓存数据 Pragma：控制浏览器不要缓存数据 Connection：响应完成后，是否断开连接 Date：告诉浏览器，服务器响应时间 状态行 例如：HTTP/1.1 200 OK 实体内容 响应包含浏览器能够解析的静态内容，例如：html，纯文字，图片等等信息","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"JS设计模式(一)——面向对象的JS","slug":"JS设计模式-一-——面向对象的JS","date":"2019-11-14T10:38:29.000Z","updated":"2019-11-15T05:25:02.563Z","comments":true,"path":"2019/11/14/JS设计模式-一-——面向对象的JS/","link":"","permalink":"http://yoursite.com/2019/11/14/JS设计模式-一-——面向对象的JS/","excerpt":"JavaScript没有提供传统面对对象语言中的类式继承，而是通过 原型委托 的方式来实现对象与对象之间的继承。","text":"JavaScript没有提供传统面对对象语言中的类式继承，而是通过 原型委托 的方式来实现对象与对象之间的继承。 动态类语言和鸭子类型 按照数据类型大体可分为两类，一类是静态类型语言，一类是动态类型语言。 鸭子类型：只关注对象的行为，而不关注对象本身。 1234567891011121314151617181920var duck = &#123; duckSinging: function() &#123; console.log('嘎嘎嘎') &#125;&#125;var chicken = &#123; duckSinging: function() &#123; console.log('嘎嘎嘎') &#125;&#125;var choir = []var joinChoir = function(animal) &#123; if(animal &amp;&amp; typeof animal.duckSinging === 'function') &#123; console.log(animal) console.log('恭喜加入合唱团') console.log('合唱团已有成员数量：'+choir.length) &#125;&#125;joinChoir(duck) //恭喜加入合唱团joinChoir(chicken) //恭喜加入合唱团 面向接口编程：例如，一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有length属性，也可以依照下标来存取属性，这个对象就可以被当作数组来使用。 多态 含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。 将“做什么”和“谁去做以及怎么样去做”分离开来，也就是将“不变的事物”与“可能改变的事物”分离开来。 1234567891011121314151617181920212223242526// 把不变的地方隔离出来，那就是所有的动物都会发出叫声var makeSound = function(animal) &#123; animal.sound()&#125;// 把可变的部分各自封装起来var Duck = function() &#123;&#125;Duck.prototype.sound = function() &#123; console.log('嘎嘎嘎')&#125;var Chicken = function() &#123;&#125;Chicken.prototype.sound = function() &#123; console.log('咯咯咯')&#125;makeSound(new Duck()) //嘎嘎嘎makeSound(new Chicken()) //咯咯咯// 增加了狗，不必改动makesound函数var Dog = function() &#123;&#125;Dog.prototype.sound = funtion() &#123; console.log('汪汪汪')&#125;makeSound(new Dog()) 类型检查：因为数据类型的限制，让代码显得僵硬。静态类型的面向对象语言通常被设计为可以向上转型：当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。 使用继承来得到多态效果，是让对象表现出多态性的最常用手段。继承通常包括实现继承和接口继承。 123456789101112131415161718192021222324252627282930313233343536public abstract class Animal &#123; abstract void makeSound();&#125;public class Ckicken extends Animal &#123; public void makeSound() &#123; System.out.println(\"咯咯咯\"); &#125;&#125;public class Duck extends Animal &#123; public void makeSound() &#123; System.out.println(\"嘎嘎嘎\"); &#125;&#125;Animal duck = new Duck();Animal chicken = new Chicken();// 让AnimalSound类的makesound方法接受Animal类型的参数public class AnimalSound &#123; public void makeSound(Animal animal) &#123; // 接受Animal类型的参数 animal.makeSound(); &#125;&#125;public class Test &#123; public static void main(String args[]) &#123; AnimalSound animalSound = new AnimalSound(); Animal duck = new Duck(); Animal chicken = new Chicken(); animalSound.makeSound(duck); // 嘎嘎嘎 animalSound.makeSound(chicken); // 咯咯咯 &#125;&#125; 归根结底先要消除类型之间的耦合关系。 多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 1234567891011121314151617181920var googleMap = &#123; show: function() &#123; console.log('开始渲染谷歌地图') &#125;&#125;var baiduMap = &#123; show: function() &#123; console.log('开始渲染百度地图') &#125;&#125;var renderMap = function( map ) &#123; if(map.show instanceof Function) &#123; map.show() &#125;&#125;renderMap(googleMap)renderMap(baiduMap) 函数本身也是对象，函数用来封装行为并且能够被四处传递。当我们对一些函数发出“调用”的消息时，这些函数会返回不同的执行结果，这是“多态性”的一种体现，也是很多设计模式在JavaScript中可以用高阶函数来代理实现的原因。 封装 封装的目的是将信息隐藏。 封装数据：一般我们通过函数来创建作用域。还可以通过Symbol创建私有变量。 从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象之间只通过暴露的API接口通信。例如，迭代器。 从设计模式的角度出发，封装在更重要的层面体现为封装变化。把系统中稳定的部分和容易变化的部分隔离开来，我们只需要替换那些容易变化的部分。 原型模式 原型模式不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。 1234567891011121314151617/** * clone方法 */var Plane = function() &#123; this.blood = 100 this.attackLevel = 1 this.defenseLevel = 1&#125;var plane = new Plane()plane.blood = 500plane.attackLevel = 10plane.defenseLevel = 7var clonePlane = Object.create(plane)console.log(clonePlane.blood) // 500 原型模式是提供了一种便捷的方式去创建某个类型的对象。 基于原型链的委托机制就是原型继承的本质。 原型编程范型： 所有的数据都是对象。 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。 对象会记住它的原型。 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 所有的数据都是对象。事实上，JavaScript中的根对象是Object.prototype对象。Object.prototype对象是一个空的对象。我们在JavaScript遇到的每个对象，实际上都是从Object.prototype对象克隆而来的，Object.prototype对象就是他们的原型。 12console.log(Object.getPrototypeof(obj1)===Object.prototype) // trueconsole.log(Object.getPrototypeof(obj2)===Object.prototype) // true 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。在JavaScript语言中，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的。我们所需要的只是显式地调用var obj1=new object()或者var obj2 = {}。此时，引擎内部会从Object.prototype上面克隆一个对象出来，我们最终得到的就是这个对象。 JavaScript的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用new运算符来调用函数时，此时的函数就是一个构造器。用new运算符来创建对象的过程，实际上也只是先克隆Object.prototype对象，再进行一些其他额外操作的过程。 123456789101112131415161718192021function Person(name) &#123; this.name = name&#125; Person.prototype.getName = function() &#123; return this.name&#125;var objectFactory = function() &#123; var obj = new Object(), //从Object.prototype上克隆一个空的对象 //[].shift.call(arguments) 删除并拿到arguments的第一项 Constructor = [].shift.call(arguments) // 取得外部传入的构造器，此例是Person obj.__proto__ = Constructor.prototype // 指向正确的原型 var ret = Constructor.apply(obj,arguments) // 借用外部传入的构造器给obj设置属性 return typeof ret === 'object' ? ret : obj; // 确保构造器总是会返回一个对象&#125;var a = objectFactory(Person,'sven')··console.log(a.name) // svenconsole.log(Object.getPrototypeOf(a) === Person.prototype) // true 对象会记住它的原型。JavaScript给对象提供了一个名为proto的隐藏属性，某个对象的proto属性默认会指向它的构造器的原型对象。虽然JavaScript中每个对象都是从Object.prototype对象克隆而来的，但对象构造器的原型并不限于Object.prototype上，而是可以动态指向其他对象。当对象a需要借用对象b的能力时，可以有选择性地把对象a的构造器的原型指向对象b，从而达到继承的效果。 123456789var obj = &#123; name: 'sven' &#125;var A = function() &#123;&#125;A.prototype = objvar a = new A()console.log(a.name) // sven// 1. 首先，尝试遍历对象a中的所有属性，但没有找到name这个属性。// 2. 查找name属性的这个请求被委托给对象a的构造器的原型，它被a.__proto__记录着并且指向A.prototype，而A.prototpye被设置为对象obj。// 3. 在对象obj中找到了name属性，并返回它的值。 1234567891011var A = function() &#123;&#125;A.prototype = &#123;name:'sven'&#125;var B = function() &#123;&#125;B.prototype = new A()var b = new B()console.log(b.name) //sven// 1. 首先，尝试遍历对象b中的所有属性，但没有找到name这个属性。// 2. 查找name属性的请求被委托给对象b的构造器的原型，它被b.__proto__记录着并且指向B.prototype，而B.prototype被设为一个通过new A()创建出来的对象。// 3. 在该对象中依然没有找到name属性，于是请求被继续委托给这个对象构造器的原型A.prototype。// 4. 在A.prototype中找到了name属性，并返回它的值。","categories":[{"name":"JS设计模式系列","slug":"JS设计模式系列","permalink":"http://yoursite.com/categories/JS设计模式系列/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"代理模式和Proxy","slug":"代理模式和Proxy","date":"2019-11-07T00:43:50.000Z","updated":"2019-11-10T03:23:19.546Z","comments":true,"path":"2019/11/07/代理模式和Proxy/","link":"","permalink":"http://yoursite.com/2019/11/07/代理模式和Proxy/","excerpt":"代理模式 保护代理：代理B可以帮A过滤掉一些请求 虚拟代理：把一些开销大的对象，延迟到真正需要它时才创建","text":"代理模式 保护代理：代理B可以帮A过滤掉一些请求 虚拟代理：把一些开销大的对象，延迟到真正需要它时才创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 简单理解代理模式：快递公司把包裹送到菜鸟驿站，菜鸟驿站作为代理收到包裹后再送给客户。下面我们就来模拟整个过程// 创建一个包裹类class Package &#123; constructor(company) &#123; this.company = company &#125;&#125;// 创建一个顺丰快递let Post = &#123; company: '顺丰快递', sendPackage(target) &#123; // 通知目标接收包裹 target.receivePackage(this.company) &#125;&#125;// 创建一个菜鸟驿站let CaiNiao = &#123; // 菜鸟驿站收到来自快递公司的包裹后要通知客户 receivePackage(from) &#123; console.log('菜鸟驿站提醒您查收包裹') Customer.waitWeenkends(() =&gt; &#123; const package = new Package(from) Customer.receivePackage(package) &#125;) &#125;&#125;// 创建一个顾客let Customer = &#123; receivePackage(package) &#123; console.log(`收到来自$&#123;package.company&#125;的包裹`) &#125;, // 顾客等到周末才会去取快递 waitWeenkends(fn) &#123; setTimeout(() =&gt; &#123;fn()&#125;,1000) &#125;&#125;//快递公司只需要关注把快递送达菜鸟驿站即可Post.sendPackage(CaiNiao)// 菜鸟驿站提醒您查收包裹// 收到来自顺丰快递的包裹 Proxy Proxy用于修改某些操作的默认行为，所以属于一种“元编程”，即对编程语言进行编程。 Proxy可以理解成再目标对象前架设一个“拦截”层，外界对该对象的访问都必须先通过这层拦截，因此提供了一种机制可以对外界的访问进行过滤和改写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// get(target,proKey,receive) 拦截对象的读取属性操作var obj = &#123;name: 'Panda'&#125;var obj1 = Object.defineProperties(&#123;&#125;, &#123; name: &#123; value: 'Panda', //如果一个属性不可配置且不可写，则Proxy不能修改该属性 writable: false, configurable: false &#125;&#125;)var p = new Proxy(obj, &#123; get: function(target,key,receive) &#123; return key === 'name' ? 'Hello' + target[key] : target[key] &#125;&#125;)p.name //HelloPanda// get拦截实现数组读取负值function createArray(...elements) &#123; let handler = &#123; get(target,propKey,receiver) &#123; let index = Number(propKey) if(index&lt;0) &#123; propKey = String(target.length + index) &#125; return Reflect.get(target,propKey,receiver) &#125; &#125; let target = [] target.push(...elements) return new Proxy(target,handler)&#125;let arr = createArray('a','b','c')console.log(arr[-1]) // c// set(obj,prop,value,receive) 拦截某个属性的赋值操作var obj = &#123;age: 18&#125;var p = new Proxy(obj, &#123; set: function(target,key,value) &#123; if(key === 'age') &#123; target[key] = Math.min(value,100) &#125; else &#123; target[key] = value &#125; &#125;&#125;)p.age = 101p.age //100obj.age //100// Proxy不能进行深度代理var obj = &#123; age:18,borth: &#123;month: 6&#125; &#125;var p = new Proxy(obj, &#123; set: function(target,key,value) &#123; console.log('exec proxy set') target[key] = value &#125;&#125;)p.borth.month = 7 //exec proxy setp.name = 'Panda'console.log(obj.name) //Panda// has(target,key) 拦截key in proxy的操作，返回一个布尔值// deleteProperty(target,proKey) 拦截delete proxy[propKey]的操作，返回一个布尔值// ownKeys(target) 拦截对象自身属性的读取操作，返回一个数组// 拦截以下操作:// Object.getOwnPropertyNames() 返回所有属性// Object.getOwnPropertySymbols()// Object.keys(proxy) 返回可枚举属性// for...in 循环var obj = Object.create(null)Object.defineProperties(obj, &#123; '_id': &#123; value: 1, configurable: true, writable: true, enumerable: true &#125;, 'name': &#123; value: 'Panda', configurable: true, writable: true, enumerable: true &#125;&#125;)Object.getOwnPropertyNames(obj) //'_id' 'name'for(let key in obj) &#123; console.log(key) // _id // name&#125;var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return Object.getOwnPropertyNames(target).filter(x =&gt; x[0]!='_') &#125;&#125;)Object.getOwnPropertyNames(p) //'name'for(let key in p) &#123; console.log(key) //name&#125;// getOwnPropertyDescriptor(target,propKey) // 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"前端面试题(文字版)","slug":"前端面试题","date":"2019-11-02T07:16:39.000Z","updated":"2019-11-10T03:24:30.925Z","comments":true,"path":"2019/11/02/前端面试题/","link":"","permalink":"http://yoursite.com/2019/11/02/前端面试题/","excerpt":"HTML HTML语义化优点？ 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析。 有利于开发维护，与CSS3关系更和谐。","text":"HTML HTML语义化优点？ 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析。 有利于开发维护，与CSS3关系更和谐。 CSS rem与em的区别 rem：相对于根元素html的font-size。假如html为font-size:12px，那么，在其当中的div设置为2rem，就相当于div的24px。 em：相对于父元素计算。假如某个p元素为font-size:12px，在它内部有个span标签，设置font-size为2em，span字体大小为24px。 什么是BFC?如何产生BFC?BFC作用？ BFC格式化上下文，它是一个独立的渲染区域，让处于BFC内部的元素和外部的元素相互隔离，使内外部元素的定位不会相互影响。 display:inline-block; position:absolute/fixed; 解决上外边距重叠；重叠的两个box都开启bfc； 解决浮动引起高度塌陷，容器盒子开启bfc； 解决文字环绕图片；左边图片div，右边文字容器p，p开启bfc。 JavaScript 下面代码输出什么？ 用var声明了name变量。意味着创建阶段会被提升（JavaScript会在创建变量阶段为其分配内存空间），默认值为undefined，直到我们实际执行到使用该变量的行，还没有赋值，所以仍然是undefined let声明的变量age，在声明之前是不可访问的，称为“暂时死区”，会抛出ReferenceError let也存在变量提升！！ 变量的赋值可以分为三个阶段： 创建变量，在内存中开辟空间 初始化变量，将变量初始化为undefined 真正赋值 关于let、var、function： let的【创建】过程被提升了，但是初始化没有提升 var的【创建】和【初始化】都被提升了 function的【创建】【初始化】和【赋值】都被提升了12345678910function sayHi() &#123; console.log(name) console.log(age) console.log('hahaha') var name = \"Panda\" let age = 21&#125;sayHi()//undefined//ReferenceError 下面代码的输出是什么？ 第一个循环中的变量i是使用var关键字声明的，因此该值是全局的。当调用setTimeout函数时，循环已经走完，i已经被赋值为3. 第二个循环中，使用let关键字声明变量i具有块级作用域。每次迭代i将被创建为一个新值，并且每个值都会存在于循环内部的块级作用域。 12345678910for(var i=0;i&lt;3;i++) &#123; setTimeout(() =&gt; console.log(i),i)&#125;for(let i=0;i&lt;3;i++) &#123; setTimeout(() =&gt; console.log(i),1)&#125;// 3 3 3// 0 1 2 下面代码的输出是什么？123456789101112const shape = &#123; radius: 10, diameter() &#123; return this.radius * 2 &#125;, perimeter: () =&gt; 2 * Math.PI * this.radius&#125;shape.diameter()shape.perimeter()// 20// NaN 对于箭头函数，this指向是它所在上下文（定义时的位置）的环境，与普通函数不同！这意味着当我们调用perimeter时，它不是指向shape对象，而是指其定义时的环境（window）。没有该属性返回undefined。 下面的代码输出是什么？12345+true;!\"Panda\";// 1// false 一元加号会尝试将boolean类型转换为数字类型。true被转换为1。false会被转换为0。 对于非空字符串是一个真值，取反会返回false。 事件传播的三个阶段是什么？ 捕获 -&gt; 目标 -&gt; 冒泡 所有对象都有原型对吗？ 除基础对象外，所有对象都有原型。基础对象可以访问某些方法和属性，例如.toString。这就是您可以使用内置JavaScript方法的原因！所有这些方法都可以在原型上找到。虽然JavaScript无法直接在您的对象上找到它，但它会沿着原型链向下寻找并在那里找到它，这使您可以访问它。 下面代码的输出是什么？1234function sum(a,b) &#123; return a + b&#125;sum(1,\"2\") //\"12\" JavaScript是一种动态类型语言，在此例中数字1进行了隐式类型转换，以使函数有意义并返回值。 下面代码的输出是什么？1234function getAge(...args) &#123; console.log(typeof args)&#125;getAge(21) //\"object\" 扩展运算符（…args）返回一个带参数的数组。数组是一个对象，因此typeof返回object。 下面代码的输出是什么？12const obj = &#123; a:\"one\" , b:\"two\" , a:\"three\" &#125;console.log(obj) //&#123; a:\"three\" , b:\"two\" &#125; 如果对象有两个具有相同名称的键，则将替前面的键。它仍将处于第一个位置，但具有最后指定的值。 HTTP","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"ES6(三)——字符串的扩展","slug":"ES6-三-——字符串的扩展","date":"2019-11-02T05:21:05.000Z","updated":"2019-11-02T05:23:44.077Z","comments":true,"path":"2019/11/02/ES6-三-——字符串的扩展/","link":"","permalink":"http://yoursite.com/2019/11/02/ES6-三-——字符串的扩展/","excerpt":"","text":"Unicode表示法JS允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点。这种表示法只限于码点在\\u000~\\uFFFF之间的字符。ES6中只要将码点放入大括号就能正确解读该字符。 ‘\\z’ === ‘z’‘\\172’ === ‘z’‘\\x7A’ === ‘z’‘\\u007A’ === ‘z’‘\\u{7A}’ === ‘z’codePointAt()JS内部字符以utf-16格式储存，每个字符固定为2个字节。codePointAt方法的参数是字符在字符串中的位置（从0开始）。 123456var s = '𠮷a'for(let ch of s) &#123; console.log(ch.codePointAt(0))&#125;// 20bb7// 61 能够正确处理4个字节储存的字符，返回一个字符串返回的码点是十进制值，toString转化成十六进制正确位置序号：for…of循环String.fromCodePoint()该方法定义在String对象上 12String.fromCodePoint(0x20bb7)// \"𠮷\" 用于从码点返回对应字符repeat()返回一个新字符串，表示将原字符串重复n次参数是小数会被取整参数是负数或Infinity会报错参数0到-1之间的小数等于0参数NaN等同于0参数是字符串，先转换成数字遍历器接口使得字符串可以for…of循环可以识别大于0xFFFF的码点类indexOf方法三个方法都返回布尔值。都支持第二个参数，表示开始搜索的位置。 includes()表示是否找到了字符串 startsWith()表示参数字符串是否在源字符串的头部。 endsWith()表示参数字符串是否在源字符串的尾部。 normalize()JS将合成字符视为两个字符，导致两种方法不等价将字符的不同表示方式统一为同样的形式at()方法类似charAt()可以识别大于0xFFFF的字符，返回正确的字符String.raw()模板字符串的处理函数返回一个反斜线都被转义的字符串字符串补全padStart() 头部补全 padEnd() 尾部补全 模板编译标签模板模板字符串反引号（`）标识表示多行字符串，空格和缩进会被保留在输出中嵌入变量写在${}中 进行运算 1234var x = 1var y = 2`$&#123;x&#125; + $&#123;y&#125; = $&#123;x+y&#125;`//\"1 + 2 = 3\" 引用对象属性 123var obj = &#123; x:1 , y:2 &#125;`$&#123;obj.x + obj.y&#125;`// 3 调用函数 12345function fn() &#123; return \"Hello World\"&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 变量没有声明，将报错 字符串原样输出 可以嵌套可以引用模板字符串本身123let str = 'return ' + '`Hello $&#123;name&#125;`'let func = new Function('name',str)func('Panda')","categories":[{"name":"ES6标准入门系列","slug":"ES6标准入门系列","permalink":"http://yoursite.com/categories/ES6标准入门系列/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"js中的数据存储","slug":"js中的数据存储","date":"2019-11-02T05:16:39.000Z","updated":"2019-11-02T05:20:09.078Z","comments":true,"path":"2019/11/02/js中的数据存储/","link":"","permalink":"http://yoursite.com/2019/11/02/js中的数据存储/","excerpt":"","text":"Cookiecookie是纯文本，存储数据当网页发送http请求时，会先检查如果有cookie 则添加至request header 特征 不同浏览器不通用 以域名形式区分 个数是有限的 大小限制4KB 设置过期时间，默认会话结束 构成 名称 唯一、不区分大小写 值 URL编码 域 cookie对于哪个域是有效的 路径 发送cookie的指定域的路径 失效时间 何时应该被删除的时间戳 安全标志 指定后cookie只有在使用ssh连接才发送到服务器 设置 客户端 document.cookie document.cookie=”username=panda;path=/;domain=qq.com” 服务端 Set-Cookie Set-Cookie:username=panda;path=/;domain=qq.com 安全性 secure设置只有在确保安全情况下才发送 document.cookie=”username=panda; secure” 应用 提示用户下一次进入网站保留用户信息 购物车选择不同商品在付款时提取 浏览计数 localStorage提供一种存储大量可以跨会话存在的数据的机制对Storage对象进行任何修改，都会在文档上触发storage事件 特征 持久化本地存储永远不会过期 在同一域是共享的 大小5M左右 存储内容多消耗内存空间，导致页面变卡 受同源策略的限制 会触发storage事件 api 存储数据 localstorage.setItem(‘username’,’panda’) localstorage.username=”panda” 获取数据 localstorage.getItem(‘username’) localstorage.username localstorage.key(0) 删除数据 localstorage.removeItem(‘username’) localstorage.clear() storage事件 domain 发生变化的存储空间域名 key 设置或删除的键名 newValue 设置键-&gt;新值；删除键-&gt;null oldValue 键被更改之前的值 应用 草稿功能 缓存后端传来的一些数据减少请求速度更快 长期登录保存在本地的数据 sessionStorage特征 会话级别的存储 关闭窗口后，即被销毁 新窗口打开同源另一个页面也是没有的 api 写入磁盘 sessionStorage.begin() sessionStorage.commit() 迭代值 length属性、key() for-in循环 删除数据 delete sessionStorage.username 其他同localstorage storage事件 同localstorage 应用 缓存关闭浏览器就丢弃的数据 敏感账号一次性登录 IndexedDB特征 浏览器中保存结构化数据的一种数据库 面向对象的（非关系型）数据库 同源访问的限制 模式 打开数据库并且开始一个事务 创建一个object store 构建一个请求来执行一些数据库操作 通过监听正确类型的DOM事件以等待操作完成 在操作结果上进行一些操作 应用 存储大量数据 不需要网络连接的纯离线应用 缓存网络请求","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JavaScript深入(七)——new的模拟实现","slug":"JavaScript深入-七-——new的模拟实现","date":"2019-10-24T09:32:41.000Z","updated":"2019-11-02T05:17:45.457Z","comments":true,"path":"2019/10/24/JavaScript深入-七-——new的模拟实现/","link":"","permalink":"http://yoursite.com/2019/10/24/JavaScript深入-七-——new的模拟实现/","excerpt":"new运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一","text":"new运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 举例： 123456789101112131415161718function Otaku(name,age) &#123; this.name = name this.age = age this.habit = 'Games'&#125;Otaku.prototype.strength = 60Otaku.prototype.sayYourName = function() &#123; console.log('I am' + this.name)&#125;var person = new Otaku('Panda','20')console.log(person.name) //Pandaconsole.log(person.habit) //Gamesconsole.log(person.strength) //60person.sayYourName() //I am Kevin 初步实现 预分析： 因为new的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫obj，因为obj会具有Otaku构造函数函数里的属性,我们可以使用Otaku.apply(obj,arguments)来给obj添加新的属性。 实例的_proto_属性会指向构造函数的prototype，也正是因为建立起这样的关系，实例可以访问原型的属性。 1234567function objectFactory() &#123; var obj = new Object() Constructor = [].shift.call(arguments) obj._proto_ = Constructor.prototype Constructor.apply(obj,arguments) return obj&#125; 事后分析： 在new Object()的方式新建了一个对象obj 取出第一个参数，就是我们要传入的构造函数。此外因为shift会修改原数组，所以arguments会被去除第一个参数 将obj的原型指向构造函数，这样obj就可以访问到构造函数原型中的属性 使用apply，改变构造函数this的指向到新建的对象，这样obj就可以访问到构造函数的属性 返回obj 1234567var person = objectFactory(Otaku,'Panda','20')console.log(person.name) //Pandaconsole.log(person.habit) //Gamesconsole.log(person.strength) //60person.sayYourName() //I am Panda 第二版代码 两种情况： 构造函数有返回值：实例中只能访问返回的对象中的属性。 构造函数返回一个基本类型：会返回值，但是相当于没有返回值进行处理。 还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。 1234567function objectFactory() &#123; var obj = new Object() Constructor = [].shift.call(arguments) obj._proto_ = Construtor.prototype var ret = Constructor.apply(obj,arguments) return typeof ret === 'object' ? ret : obj&#125;","categories":[{"name":"JS深入系列","slug":"JS深入系列","permalink":"http://yoursite.com/categories/JS深入系列/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"ES6(二)——变量的解构赋值","slug":"ES6-二-——变量的解构赋值","date":"2019-10-19T01:38:59.000Z","updated":"2019-10-19T01:43:42.690Z","comments":true,"path":"2019/10/19/ES6-二-——变量的解构赋值/","link":"","permalink":"http://yoursite.com/2019/10/19/ES6-二-——变量的解构赋值/","excerpt":"","text":"对象解构用于对象变量必须与属性同名才能取到正确的值let { bar,foo } = { foo:”aaa”,bar:”bbb” } foo //“aaa” bar //“bbb” 变量名与属性名不一致var { foo:baz } = { foo:’aaa’ , bar:’bbb’ }baz //“aaa” 匹配模式和变量//foo是匹配模式，baz才是变量let { foo:baz } = { foo:”aaa” , bar: “bbb” }baz //“aaa”foo //error:foo is not defined 嵌套赋值let obj = {}let arr = []({ foo:obj.prop , bar: arr[0] } = { foo:123 , bar: true })obj //{prop:123}arr //[true] 指定默认值var { x,y=5 } = { x:1 }x //1y //5 报错 对已声明变量解构赋值 大括号在行首 JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误 现有对象的方法赋值到变量上let { log,sin,cos } = Math 对数组进行对象属性的解构let { 0:first , [arr.length - 1]: last } = arr 数值和布尔值先转为对象解构赋值的规则是，只要等号右边不是对象或数组，就先将其转化为对象。let { toString:s } = 123s === Number.prototype.toString //truelet { toString:s } = trues === Boolean.prototype.toString //true 函数参数函数参数也可以解构赋值指定默认值字符串转换成了一个类似数组的对象const [a,b,c,d,e] = ‘hello’a //“h”b //“e”c //“l”d //“l”e //“o” length属性let {length:len} = ‘hello’len //5 圆括号问题不能使用圆括号 变量声明语句 let {x:(c)} = {}let [(a)] = [1] 函数参数 function f([(z)]) { return z } 赋值语句的模式 ({ p:a }) = { p:52 } 可以使用圆括号 赋值语句的非模式 [(b)] = [3] 用途交换变量的值let x = 1let y = 2[x,y] = [y,x] 从函数返回多个值function example() { return [1,2,3]} let [a,b,c] = example() 函数参数的定义function f([x,y,z]) {..}f([1,2,3]) 提取JSON数据let jsonData = { id: 42, status: “OK”, data: [111,000]} let { id,status,data:number } = jsonData 函数参数的默认值遍历Map结构var map = new Map()map.set(‘first’,’hello’)map.set(“second”,”world”) for(let [key,value] of map ) { console.log(key + “ is “ + value )} //first is hello//second is world 输入模块的指定方法const { SourceMapConsumer, SourceNode } = require(“source-map”) 数组模式匹配 模式相同，变量就会被赋予到对应的值 let [a,b,c] = [1,2,3]let [foo,[[bar],baz]] = [1,[[2],3]] foo //1 bar //2 baz //3let [ , , third] = [“foo”,”bar”,”baz”] third //&quot;baz&quot;let [x,y,…z] = [‘a’] x //&quot;a&quot; y //undefined z //[] 解构不成功变量的值就等于undefined let [foo] = []foo //undefined 不完全解构 let [x,y] = [1,2,3]x //1y //2 具有Iterator接口的数据结构 如果等号的右边不是数组（不可遍历的结构），那么将会报错。转化为对象以后不具有Iterator接口：number、boolean、NaN、undefined、null本身就不具备Iterator接口：objectSet结构也可以使用数组的解构赋值：let [x,y,z] = new Set([‘a’,’b’,’c’]) 默认值 允许指定默认值 let [x=1] = [undefined] x //1如果数组成员是null则默认值不会生效:let [x=1] = [null] x// null 因为null不严格等于undefined 表达式则惰性求值 function f() { console.log(&apos;aaa&apos;)} let [x=f()] = [1] 默认值引用解构赋值的其他已声明变量 let [x=y,y=1] = []//ReferenceError","categories":[{"name":"ES6标准入门系列","slug":"ES6标准入门系列","permalink":"http://yoursite.com/categories/ES6标准入门系列/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"ES6(一)——let和const命令","slug":"ES6-一-——let和const命令","date":"2019-10-09T13:48:46.000Z","updated":"2019-10-10T11:54:59.426Z","comments":true,"path":"2019/10/09/ES6-一-——let和const命令/","link":"","permalink":"http://yoursite.com/2019/10/09/ES6-一-——let和const命令/","excerpt":"let命令基本用法 所声明的变量只在let命令所在的代码块内有效。","text":"let命令基本用法 所声明的变量只在let命令所在的代码块内有效。 123456&#123; let a = 10 var b = 1&#125;a //ReferenceError: a is not definedb //1 for循环的计数器就很适合使用let命令。计数器i只在for循环体内有效，在循环体外引用就会报错。 这段代码，变量i是var声明的，在全局范围内都有效，所以全局只有一个变量i。 1234567var a = []for(var i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i) &#125;&#125;a[6]() //10 这段代码，变量是let声明的，所以每一次循环的i都是一个新的变量。JavaScript引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。for循环在设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 123456789101112131415var a = []for(let i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i) &#125;&#125;a[6]() //6for(let i = 0;i &lt; 3; i++) &#123; let i = 'abc' console.log(i)&#125;//abc//abc//abc 不存在变量提升 它所声明的变量一定要在声明后使用，否则就会报错。 12console.log(bar) //报错ReferenceErrorlet bar = 2 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前就使用这些变量，就会报错。 12345var tmp = 123if(true) &#123; tmp = 'abc' //ReferenceError let tmp //这个tmp声明使得它绑定到块级作用域中&#125; “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。作为比较，如果一个变量根本没被声明，使用typeof反而不会报错。 123456789typeof x //ReferenceErrorlet xtypeof undeclared_variable //\"undefined\"function bar(x = y, y = 2) &#123; //x的默认值等于另一个参数y，而此时y还没有声明 return [x,y]&#125;bar() //报错 本质：只要进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用变量。 不允许重复声明 let不允许在相同作用域内重复声明同一个变量。因此，不能在函数内部重新声明参数。 123function func(arg) &#123; let arg //报错&#125; 块级作用域 为什么需要块级作用域： 内层变量可能覆盖外层变量。 用来计数的循环变量泄露为全局变量。 ES6允许块级作用域的任意嵌套；外层作用域无法读取内存作用域的变量；内层作用域可以定义外层作用域的同名变量。 ES6明确声明允许块级作用域之中声明函数。应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式的形式。 do表达式 在块级作用域之前加上do，使它变成do表达式，使得块级作用域可以变为表达式，即可以返回值。 1234let x = do &#123; let t = f() t * t + 1 b &#125; const命令 const声明一个只读的常量。一旦声明，就必须立即初始化，常量的值就不能改变。 和let命令相同点： 只在声明所在的块级作用域内有效。 声明的常量也不会提升。 存在暂时性死区。 只能声明后使用。 不可重复声明。 const实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据而言，值就保存在变量指向的内存地址中，因此等同于常量。但对于复合类型的数据而言，变量指向的内存地址保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，这完全不能控制。 即不能把对象/数组指向另一个地址，但本身是可变的。如果真想冻结对象，应该使用Object.freeze方法。 12345678const foo = &#123;&#125;foo.prop = 123 //可执行foo = &#123;&#125; //ReferenceErrorconst a = []a.push('panda') //可执行a.length = 0 //可执行a = ['bear'] //报错 顶层对象的属性 var命令和function命令声明的全局变量依然是顶层对象的属性；let命令、const命令、class命令声明的全局变量不属于顶层对象的属性。","categories":[{"name":"ES6标准入门系列","slug":"ES6标准入门系列","permalink":"http://yoursite.com/categories/ES6标准入门系列/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JavaScript深入(六)——call和apply模拟实现","slug":"JavaScript深入-六-——call和apply模拟实现","date":"2019-10-01T13:01:12.000Z","updated":"2019-10-09T13:52:56.204Z","comments":true,"path":"2019/10/01/JavaScript深入-六-——call和apply模拟实现/","link":"","permalink":"http://yoursite.com/2019/10/01/JavaScript深入-六-——call和apply模拟实现/","excerpt":"call call()方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法。","text":"call call()方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法。 123456789var foo = &#123; value: 1&#125;function bar() &#123; console.log(this.value)&#125;bar.call(foo) //1 注意两点： call改变了this的指向，指向到foo bar函数执行了 模拟实现第一步试想当调用call的时候，把foo对象改造如下： 1234567var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125; foo.bar() //1&#125; 但是，这样却给foo对象本身添加了一个属性！所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 123456789101112131415Function.prototype.call2 = function(context) &#123; context.fn = this context.fn() delete context.fn&#125;var foo = &#123; value: 1&#125;function bar() &#123; console.log(this.value)&#125;bar.call2(foo) //1 模拟实现第二步call函数还能给定参数执行函数： 1234567891011121314var foo = &#123; value: 1&#125;function bar(name,age) &#123; console.log(name) console.log(age) console.log(this.value)&#125;bar.call(foo,'panda',19)//panda//19//1 不固定参数：我们可以从Arguments对象中取值，取出第二个到最后一个参数，然后放到一个数组里。 123456789Function.prototype.call2 = function(context) &#123; context.fn = this var args = [] for(var i = 1,len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']') &#125; eval('context.fn(' + args + ')') //这里args会自动调用Array.toString()方法 delete context.fn&#125; 模拟实现第三步 this参数可以传null，当为null的时候，视为指向window 函数是可以有返回值的！ 1234567891011Function.prototype.call2 = function(context) &#123; var context = context || window //默认是window context.fn = this var args = [] for(var i = 1,len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']') &#125; var result = eval('context.fn(' + args + ')') //结果赋值 delete context.fn return result //返回结果&#125; apply的模拟实现apply和call的区别在于传入参数的方式，apply是一个数组 12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; //如果没有参数 result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; //直接用arr.length了 args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125;","categories":[{"name":"JS深入系列","slug":"JS深入系列","permalink":"http://yoursite.com/categories/JS深入系列/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JavaScript深入(五)——闭包","slug":"JavaScript深入-五-——闭包","date":"2019-09-29T02:07:26.000Z","updated":"2019-10-09T13:52:35.647Z","comments":true,"path":"2019/09/29/JavaScript深入-五-——闭包/","link":"","permalink":"http://yoursite.com/2019/09/29/JavaScript深入-五-——闭包/","excerpt":"定义 闭包是指那些能够访问自由变量的函数。","text":"定义 闭包是指那些能够访问自由变量的函数。 什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数而不是函数的局部变量的变量。 闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量。 举个例子 123456var a = 1function foo() &#123; console.log(a)&#125;foo() foo函数可以访问变量a，但是a既不是foo函数的局部变量，也不是foo函数的参数，所以a就是自由变量。 那么，函数foo + foo 函数访问的自由变量a就构成了一个闭包 《Javascript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 对于闭包的理解： 从理论角度：所有的函数。因为它们都在创建的时候就将上下文的数据保存起来了。哪怕是最简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 分析12345678910var scope = \"global scope\"function checkscope() &#123; var scope = \"local scope\" function f() &#123; return scope &#125; return f&#125;var foo = checkscope()foo() 执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入上下文栈 全局执行上下文初始化 执行checkscope函数，创建checkscope函数执行上下文，checkscope执行上下文被压入上下文栈 checkscope执行上下文初始化，创建变量对象、作用域链、this等 checkscope函数执行完毕，checkscope执行上下文从执行上下文栈中弹出 执行f函数，创建f函数执行上下文，f执行上下文被压入执行上下文栈 f执行上下文初始化，创建变量对象、作用域链、this等 f函数执行完毕，f函数上下文从执行上下文栈中弹出 当f函数执行时，checkscope函数上下文已经被销毁了，但是f执行上下文维护了一个作用域链 123fContext = &#123; Scope: [AO , checkscopeContext.AO , globalContext.VO]&#125; 即使checkscopeContext被销毁了，但是JavaScript依然会让checkscopeContext.AO活在内存里，f函数依然可以通过f函数的作用域链找到它。 必刷题123456789var data = []for(var i = 0; i &lt; 3; i++) &#123; data[i] = function() &#123; console.log(i) &#125;&#125;data[0]() //3data[1]() //3data[2]() //3 当执行到data[0]函数之前，此时全局上下文的VO为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行data[0]函数的时候，data[0]函数的作用域链为： 123data[0]Context = &#123; Scope: [AO , globalContext.VO]&#125; data[0]Context的AO并没有i值，所以会从globalContext.VO中查找。i为3，所以打印的结果就是3。 改成闭包类型123456789101112var data = []for(var i = 0; i &lt; 3; i++) &#123; data[i] = (function(i) &#123; return function() &#123; console.log(i) &#125; &#125;)(i)&#125;data[0]()data[1]()data[2]() 当执行到data[0]函数之前，此时全局上下文的VO和前面相同。 但执行data[0]函数的时候，data[0]函数的作用域链发生了改变： 123data[0]Context = &#123; Scope: [AO , 匿名函数Context.AO , globalContext.VO]&#125; 匿名函数执行上下文的AO为： 123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context的AO并没有i值，所以会沿着作用域链从匿名函数Context.AO中查找，这时候就会找到i为0。","categories":[{"name":"JS深入系列","slug":"JS深入系列","permalink":"http://yoursite.com/categories/JS深入系列/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"DOM基础","slug":"DOM基础","date":"2019-09-27T13:17:43.000Z","updated":"2019-09-27T13:30:26.151Z","comments":true,"path":"2019/09/27/DOM基础/","link":"","permalink":"http://yoursite.com/2019/09/27/DOM基础/","excerpt":"节点层次文档节点只有一个子节点，即元素，我们称之为文档元素","text":"节点层次文档节点只有一个子节点，即元素，我们称之为文档元素 Document Element html Element head Element title Text Sample Page Element body Element p Text Hello World! Node类型JavaScript中的所有节点类型都继承自Node类型 nodeType Node.ELEMENT_NODE(1) Node.ATTRIBUTE_NODE(2) Node.TEXT_NODE(3) Node.DOCUMENT_NODE(9) childNodes保存着一个NodeList对象。NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点 parentNode该属性指向文档树中的父节点。包含在childNodes列表中的所有节点都具有相同的父节点。因此它们的parentNode属性都指向同一个节点。 ownerDocument该属性指向表示整个文档的文档节点 appendChild()向childNodes列表的末尾添加一个节点 insertBefore()把节点放在childNodes列表中某个特定的位置上，而不是放在末尾两个参数：要插入的节点和作为参照的节点 replaceChild()接受的两个参数是：要插入的节点和要替换的节点。 removeChild()接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值。 cloneNode()接受一个布尔值参数。在参数为true的情况下，执行深复制，也就是复制节点及其整个子节点树。在参数为false的情况下，执行浅复制，即只复制节点本身。 normalize()处理文档树中的文本节点：如果找到了空文本节点。则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点 DocumentFragment类型它可以作为一个“仓库”来使用，即可以在里面保存将来可能会添加到文档中的节点。Comment类型Text类型Element类型HTML元素 HTMLElement类型直接继承自Element并添加了一些属性 操作特性 getArrtibute() 通过getArrtibute()方法也可以取得自定义特性的值。在通过该方法访问style时，返回的是CSS文本，而通过属性访问则返回一个对象。通过该方法访问onclick这样的事件处理程序会返回相应代码的字符串。 setArribute() removeAttribute() 创建元素 createElement() 元素的子节点 元素间的空白符也是一个文本节点 getElementByTagName() Document类型是HTMLDocument(继承自Document类型)的一个实例属性 URL 包含页面完整的URL(即地址栏中显示的URL) domain 只包含页面的域名 referrer 保存着连接到当前页面的那个页面的URL 查找元素 getElementById() 如果页面中出现多个元素的Id值相同，只返回文档中第一次出现的元素。 getElementByTagName() 返回的是包含多个元素的NodeList，在HTML文档中，会返回一个HTMLCollection。HTMLCollection还有一个方法叫nameItem()，可以通过元素的name特性取得集合中的项。想取得文档中的所有元素，传入 * 。 getElementByName() 文档写入 write() writeln() 会在字符串结尾添加一个换行符（\\n） open() close() XMind: ZEN - Trial Version","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"git基本操作","slug":"git基本操作","date":"2019-09-25T10:47:57.000Z","updated":"2019-09-26T06:15:36.836Z","comments":true,"path":"2019/09/25/git基本操作/","link":"","permalink":"http://yoursite.com/2019/09/25/git基本操作/","excerpt":"一、git创建仓库git init1git init Git的很多命令都需要再Git的仓库中运行，所以git init是使用git的第一个命令。 在执行完git init之后，Git仓库会生成一个.git目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。","text":"一、git创建仓库git init1git init Git的很多命令都需要再Git的仓库中运行，所以git init是使用git的第一个命令。 在执行完git init之后，Git仓库会生成一个.git目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。 git clone12git clone &lt;repo&gt;git clone &lt;repo&gt; &lt;directory&gt; //到指定目录 repo: Git仓库 directory: 本地目录 二、基本操作git add git add命令可将该文件添加到缓存。 我们可以使用下面的命令来添加当前项目的所有文件。 1git add . git status 查看在上次提交之后是否有修改。 该命令加上 -s 参数，以获得简短的结果输出。 1git status git diff 查看执行git status的结果的详细信息。 git diff命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。 尚未缓存的改动：git diff 查看已缓存的改动：git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个diff：git diff –stat git commit 使用git add命令将想要快照的内容写入缓存区，而执行git commit将缓存区内容添加到仓库中。 Git为你的每一个提交都记录，第一步配置用户名和邮箱地址。 config --global user.name 'panda'1git config --global user.email panda@qq.com 如果觉得git add提交缓存的流程太过繁琐，Git也允许用 -a 选项跳过这一步。 1git commit -a 修改文件内容后，执行以下命令 1git commit -m &quot;change something&quot; git reset HEAD git reset HEAD 命令用于取消已缓存的内容。 1git reset HEAD readme.md git rm 如果只是简单地从工作目录中手工删除文件，运行git status时就会在Changes not staged for commit的提示。 要从Git中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。 1git rm &lt;file&gt; 如果删除之前修改过并且已经放到暂存区域的话，则必须要强制删除选项 -f 1git rm -f &lt;file&gt; 三、Git分支管理列出分支 没有参数时，git branch会列出你在本地的分支 1git branch 执行git init的适合，默认情况下Git就会为你创建master分支。手动创建分支： 1git branch branchname 切换分支 切换分支 1git checkout (branch) 可以使用git checkout -b (branchname)来创建新分支并立即切换到该分支下 删除分支 删除本地分支： 12git branch -d (branchname)git branch -D (branchname) //强制删除 删除远程分支： 1git push origin --delete (branchname) 分支合并 一旦某分支有了独立内容，可以使用一下命令将任何分支合并到当前分支中去 1git merge (branchname) push和pull分支 本地推送分支： 1git push origin (branchname) pull分支： 1git pull origin (branchname)","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"单例模式","slug":"单例模式","date":"2019-09-21T05:10:55.000Z","updated":"2019-09-21T06:04:04.346Z","comments":true,"path":"2019/09/21/单例模式/","link":"","permalink":"http://yoursite.com/2019/09/21/单例模式/","excerpt":"单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点","text":"单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点 什么是单例模式例子：在页面中点击登录按钮，弹出了一个登录浮窗，这个登录浮窗是唯一的，无论我们单击多少次，浮窗只会创建一次。单例模式的核心是确保只有一个实例，并提供全局访问。 降低全局污染 使用命名空间 适当使用命名空间，并不会杜绝全局变量，但是可以减少全局变量的数量。 使用闭包封装私有变量 123456789var payen = (function() &#123; var _name = 'panda', _age = 19 return &#123; getinfo: function() &#123; return _name + ' ' + _age &#125; &#125;&#125;)() 变量被封装在了闭包内，只暴露一些接口用于外部通信，从而避免了对全局的命令污染。 简单的惰性单例模式12345678910111213141516var createDiv = (function() &#123; var div return function() &#123; if(!div) &#123; div = document.createElement('div') div.style.width = '100px' div.style.height = '100px' div.style.background = 'red' document.body.appendChild(div) &#125; &#125;&#125;)()createDiv()createDiv()createDiv() 使用单例模式让它只创建一个div 问题： 违反了单一职责原则，创建对象和管理单例放在了一个函数中createDiv 如果我们还想创建一个其他的对象，那就只能copy了 综上，我们需要：把不变的部分隔离出来，把可变的封装起来，这给予了我们扩展程序的能力，符合开发-封闭原则 抽出管理单例12345678910111213141516171819var getSingle = function(fn) &#123; var result return function() &#123; return result || (result = fn.apply(this, arguments)) &#125;&#125;var createDiv = function() &#123; var div = document.createElement('div') div.style.width = '100px' div.style.height = '100px' div.style.background = 'red' document.body.appendChild(div) return div&#125;var createSingDiv = getSingle(createDiv)createSingleDiv()createSingleDiv()createSingleDiv() 创建的DOM节点保存在了result中，result变量因为自身在闭包中，不会被销毁，在将来的请求中，如果result已经被赋值了，那么它将返回这个值。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JavaScript深入(四)——this机制","slug":"JavaScript深入-四-——this机制","date":"2019-09-20T07:16:33.000Z","updated":"2019-10-09T13:52:43.113Z","comments":true,"path":"2019/09/20/JavaScript深入-四-——this机制/","link":"","permalink":"http://yoursite.com/2019/09/20/JavaScript深入-四-——this机制/","excerpt":"this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。","text":"this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。 例子1123456function a() &#123; var user = \"panda\" console.log(this.user) //undefined console.log(this) //Window&#125;a() this最终指向的是调用它的对象，这里的函数a实际是被Window对象所点出来的。 123456function a() &#123; var user = \"panda\" console.log(this.user) //undefined console.log(this) //Window&#125;window.a() 和上面的代码一样，其实alert也是window的一个属性，也是window点出来的。 例子21234567var o = &#123; user: 'panda', fn: function() &#123; console.log(this.user) //panda &#125;&#125;o.fn() 这里的this指向的是对象o，因为你调用这个fn是通过o.fn()执行的，那自然指向就是对象o，this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁。 例子31234567var o = &#123; user: 'panda', fn: function() &#123; console.log(this.user) //panda &#125;&#125;window.o.fn() 再一个例子 123456789var o = &#123; a: 10, b: &#123; a: 12, fn: function() &#123; console.log(this.a) //12 &#125; &#125;&#125; 情况1：如果一个函数中有this，但是他没有被上一级的对象调用，那么this指向的就是window（严格模式不符合）。 情况2：如果一个函数中有this，这个函数又被上一级的对象所调用，那么this指向的就是上一级的对象。 情况3: 如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级对象。 123456789var o = &#123; a: 10, b: &#123; fn: function() &#123; console.log(this.a) //undefined &#125; &#125;&#125;o.b.fn() 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。 特殊情况123456789101112var o = &#123; a: 10, b: &#123; a: 12, fn: function() &#123; console.log(this.a) //undefined console.log(this) //window &#125; &#125;&#125;var j = o.b.fnj() 这里的this指向的是window。this永远指向的是最后调用它的对象。 this碰到return1234567891011121314function fn() &#123; this.user = 'panda' return &#123;&#125;&#125;var a = new fnconsole.log(a.user) //undefinedfunction bn() &#123; this.user = 'panda' return 1&#125;var b = new bnconsole.log(b.user) //panda 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。 补充 严格版中的默认的this操作不再是window，而是undefined。 new操作符会改变函数this的指向问题。","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JavaScript深入(三)——作用域和执行上下文","slug":"JavaScript深入-三-——作用域和执行上下文","date":"2019-09-18T12:33:41.000Z","updated":"2019-10-09T13:52:49.444Z","comments":true,"path":"2019/09/18/JavaScript深入-三-——作用域和执行上下文/","link":"","permalink":"http://yoursite.com/2019/09/18/JavaScript深入-三-——作用域和执行上下文/","excerpt":"作用域 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript采用词法作用域，也就是静态作用域。","text":"作用域 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript采用词法作用域，也就是静态作用域。 静态作用域 因为JavaScript采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。12345678910111213var value = 1function foo() &#123; console.log(value)&#125;function bar() &#123; var value = 2 foo()&#125;bar() 执行foo函数，先从foo函数内部查找是否有局部变量value，如果没有，就根据书写的位置，查找上面一层的代码，也就是value等于1，所以结果会打印1。 顺序执行？例一 12345678var foo = function () &#123; console.log('foo1')&#125;foo() //foo1var foo = function () &#123; console.log('foo2')&#125;foo() //foo2 例二 12345678function foo() &#123; console.log('foo1')&#125;foo() //foo2function foo() &#123; console.log('foo2')&#125;foo() //foo2 可执行代码全局代码、函数代码、eval代码 执行上下文 JavaScript引擎创建了执行上下文栈来管理执行上下文为了模拟执行上下文栈的行为，定义执行上下文栈是一个数组： ECStack = [] 当JavaScript开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用globalContext表示它，并且只有当整个应用程序结束的时候，ECStack才会被清空，所以ECStack最底部永远有个globalContext： 123ECStack = [ globalContext] 现在JavaScript遇到下面这段代码了： 12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3()&#125;function fun1() &#123; fun2()&#125;fun1() 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。 1234567891011121314151617//fun1()ECStack.push(&lt;fun1&gt; functionContext)// fun1调用fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext)//fun2调用fun3ECStack.push(&lt;fun3&gt; functionContext)//fun3执行完毕ECStack.pop()//fun2执行完毕ECStack.pop()//fun1执行完毕ECStack.pop()","categories":[{"name":"JS深入系列","slug":"JS深入系列","permalink":"http://yoursite.com/categories/JS深入系列/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"vue源码分析","slug":"vue源码分析","date":"2019-09-14T07:55:37.000Z","updated":"2019-09-18T12:32:44.434Z","comments":true,"path":"2019/09/14/vue源码分析/","link":"","permalink":"http://yoursite.com/2019/09/14/vue源码分析/","excerpt":"数据代理 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）。 vue数据代理：通过vm对象来处理data中所有属性的操作。 好处：更方便的操作data中的数据。","text":"数据代理 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）。 vue数据代理：通过vm对象来处理data中所有属性的操作。 好处：更方便的操作data中的数据。 123456789const vm = new Vue(&#123; el: '#test', data: &#123; name: 'Panda', &#125;&#125;)console.log(vm.name) //panda vm代理对data数据的读操作vm.name = 'cat' //vm代理对data数据的写操作console.log(vm._data.name) //cat 基本实现流程： 通过Object.defineProperty()给vm添加与data对象的属性对应的属性描述符。 所有添加的属性都包含getter/setter getter/setter内部去操作data中对应的属性数据。 1234567891011121314151617_proxyData: function(key, setter, getter) &#123; //保存vm var me = this; setter = setter || Object.defineProperty(me, key, &#123; configurable: false, //不能重新定义 enumerable: true, //可以枚举遍历 //当通过vm.xxx读取属性值时调用，从data中获取对应的属性值返回 代理读操作 get: function proxyGetter() &#123; return me._data[key]; &#125;, //当通过vm.xxx = value时，value被保存到data中对应的属性上 代理写操作 set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;);&#125; 模板解析模板解析的基本流程 将el的所有子节点取出，添加到一个新建的文档fragment对象中。 对fragment中的所有层次子节点递归进行编译解析处理。 对表达式文本节点进行解析 对元素节点的指令属性进行解析 事件指令解析","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"JavaScript深入(二)——getter与setter的使用","slug":"JavaScript深入-二-——getter与setter的使用","date":"2019-09-12T12:42:08.000Z","updated":"2019-10-09T13:53:18.834Z","comments":true,"path":"2019/09/12/JavaScript深入-二-——getter与setter的使用/","link":"","permalink":"http://yoursite.com/2019/09/12/JavaScript深入-二-——getter与setter的使用/","excerpt":"基本用法定义JavaScript对象的属性是由名字、值和一组特性（可写、柯枚举、可配置等）构成的。属性值可以用一个或两个方法代替，就是getter和setter。 123456789var myObj = &#123; a: 2, get b() &#123; return 3 &#125;&#125;console.log(myObj.a) //2console.log(myObj.b) //3 上面的代码中，属性a称为数据属性，它只有一个简单的值；属性b用getter和setter方法定义的属性称为存取器属性。","text":"基本用法定义JavaScript对象的属性是由名字、值和一组特性（可写、柯枚举、可配置等）构成的。属性值可以用一个或两个方法代替，就是getter和setter。 123456789var myObj = &#123; a: 2, get b() &#123; return 3 &#125;&#125;console.log(myObj.a) //2console.log(myObj.b) //3 上面的代码中，属性a称为数据属性，它只有一个简单的值；属性b用getter和setter方法定义的属性称为存取器属性。 特性 存取器属性定义为一个或两个与属性同名的函数。 当程序查询存取器的属性值时，JavaScript调用getter方法（无参数），这个方法的返回值就是该属性存取表达式的值。当程序设置一个存取器属性值时，JavaScript调用setter方法，将赋值表达式右侧的值当作参数传入setter，将赋值表达式右侧的值当作参数传入setter。从某种意义上来说，这个方法负责设置属性值，可以忽略该方法的返回值。 当一个属性被定义为存取器属性时，JavaScript会忽略它的value和writable特性，取而代之的是set和get（还有configurable和enumerable）特性。 12345678910var myObj = &#123; get a() &#123; return this._a_; &#125;, set a(val)&#123; this._a_ = val &#125;&#125;myObj.a = 3console.log(myObj.a) //3 getter和setter方法中的this都指向myObj对象。 存取器属性也是可以继承的： 12var anotherObj = Object.create(myObj)console.log(another.a) //3 Object.defineProperty语法 Object.defineProperty(obj,prop,descriptor)，该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。 参数： obj：要在其上定义属性的对象。 prop：要定义或修改的属性的名称。 descriptor：将被定义或修改的属性描述符。 属性描述符： configurable：当且仅当该属性的configurable为true时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为false。 enumerable：当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为false。 value：该属性对应的值，可以是任何有效的JavaScript值（数值，对象，函数等）。默认为undefined。 writable：当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为false。 get：一个给属性提供getter的方法，如果没有getter则为undefined。当访问该属性时，该方法被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为undefined。 set：一个给属性提供setter的方法，如果没有setter则为undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。 示例123456789101112131415161718192021var o = &#123;&#125; //创建一个新对象Object.defineProperty(o,\"a\",&#123; value: 37, writable: true, enumerable: true, configurable: true&#125;)// 对象o拥有了属性a，值为37var bValueObject.defineProperty(o,\"b\", &#123; get: function() &#123; return bValue &#125;, set: function(newValue) &#123; bValue = newValue &#125;, enumerable: true, configurable: true&#125;)","categories":[{"name":"JS深入系列","slug":"JS深入系列","permalink":"http://yoursite.com/categories/JS深入系列/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JavaScript深入(一)——原型链","slug":"JavaScript深入-一-——原型链","date":"2019-09-12T07:34:37.000Z","updated":"2019-10-09T13:52:04.979Z","comments":true,"path":"2019/09/12/JavaScript深入-一-——原型链/","link":"","permalink":"http://yoursite.com/2019/09/12/JavaScript深入-一-——原型链/","excerpt":"构造函数创建对象123456function Person() &#123;&#125;var person = new Person()person.name = 'Panda'console.log(person.name) // Panda 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象person。","text":"构造函数创建对象123456function Person() &#123;&#125;var person = new Person()person.name = 'Panda'console.log(person.name) // Panda 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象person。 prototype每个函数都有一个prototype属性。 12345678function Person() &#123;&#125;Person.prototype.name = 'Panda'var person1 = new Person()var person2 = new Person()console.log(person1.name) // Pandaconsole.log(person2.name) // Panda 其实，函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是person1和person2的原型。 原型：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。 proto这是每一个JavaScript对象（除了null）都具有的一个属性，叫_proto_，这个属性会指向该对象的原型。 12345function Person() &#123;&#125;var person = new Person()console.log(person._proto_ === Person.prototype) //true constructor每一个原型都有一个constructor属性指向关联的构造函数。 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor) //true 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 1234567891011function Person() &#123;&#125;Person.prototype.name = 'Panda'var person = new Person()person.name = 'Cat'console.log(person.name) //Catdelete person.nameconsole.log(person.name) //Panda 原型的原型原型也是一个对象，既然是对象，就可以用最原始的方法创建它。 123var obj = new Object()obj.name = 'Panda'console.log(obj.name) //Panda 其实原型对象就是通过Object构造函数生成的，实例的_proto_指向构造函数的prototype。 Object.prototype没有原型（_proto_的值为null） 查找属性的时候查到Object.prototype就可以停止查找了。 补充constructor1234function Person() &#123; var person = new Person() console.log(person.constructor === Person) //true&#125; 当获取person.constructor时，其实person中并没有constructor属性，当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有该属性。 继承关于继承，引用《你不知道的JavaScript》中的话 继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更精确些。","categories":[{"name":"JS深入系列","slug":"JS深入系列","permalink":"http://yoursite.com/categories/JS深入系列/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"flex布局","slug":"flex布局","date":"2019-09-01T07:41:29.000Z","updated":"2019-09-02T01:19:59.309Z","comments":true,"path":"2019/09/01/flex布局/","link":"","permalink":"http://yoursite.com/2019/09/01/flex布局/","excerpt":"flex-direction属性 决定主轴的方向（即项目的排列方向） row(默认值)：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。","text":"flex-direction属性 决定主轴的方向（即项目的排列方向） row(默认值)：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性 默认情况下，项目都排在轴线上，flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-content属性 定义了项目在主轴上的对齐方式。 flex-start(默认值)：左对齐。 flex-end：右对齐。 center：居中。 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性 定义项目在交叉轴上如何对齐 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline：项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认）：轴线占满整个交叉轴。 选择单个元素 html 12345&lt;article&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/article&gt; css 123456article:first-child&#123; align-self: flex-start;&#125;article:nth-child(2)&#123; align-self:center;&#125; flex-grow属性 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis属性 定义了在分配多于空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值，则项目将占据固定空间。 flex属性 是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。 order属性 定义项目的排列顺序。数值越小，排列越靠前，默认为0 定位元素在弹性布局中的表现 绝对定位没有了空间位，flex布局会失效。 相对定位保留了空间位，flex布局仍有效果。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"转载：JS中的块级作用域，var、let、const三者的区别","slug":"转载：JS中的块级作用域，var、let、const三者的区别","date":"2019-08-22T02:08:30.000Z","updated":"2019-08-22T02:15:29.917Z","comments":true,"path":"2019/08/22/转载：JS中的块级作用域，var、let、const三者的区别/","link":"","permalink":"http://yoursite.com/2019/08/22/转载：JS中的块级作用域，var、let、const三者的区别/","excerpt":"首先，ECMAScript和JavaScript关系： ECMAScript是一个国际通过的标准化脚本语言。JavaScript由ECMAScript和DOM、BOM三者组成。可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。","text":"首先，ECMAScript和JavaScript关系： ECMAScript是一个国际通过的标准化脚本语言。JavaScript由ECMAScript和DOM、BOM三者组成。可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。 1.块作用域{ }JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。 块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &#123; var a = 1; console.log(a); // 1&#125;console.log(a); // 1// 可见，通过var定义的变量可以跨块作用域访问到。(function A() &#123; var b = 2; console.log(b); // 2&#125;)();// console.log(b); // 报错，// 可见，通过var定义的变量不能跨函数作用域访问到if(true) &#123; var c = 3;&#125;console.log(c); // 3for(var i = 0; i &lt; 4; i++) &#123; var d = 5;&#125;;console.log(i); // 4 (循环结束i已经是4，所以此处i为4)console.log(d); // 5// if语句和for语句中用var定义的变量可以在外面访问到，// 可见，if语句和for语句属于块作用域，不属于函数作用域。&#123; var a = 1; let b = 2; const c = 3; &#123; console.log(a); // 1 子作用域可以访问到父作用域的变量 console.log(b); // 2 子作用域可以访问到父作用域的变量 console.log(c); // 3 子作用域可以访问到父作用域的变量 var aa = 11; let bb = 22; const cc = 33; &#125; console.log(aa); // 11 // 可以跨块访问到子 块作用域 的变量 // console.log(bb); // 报错 bb is not defined // console.log(cc); // 报错 cc is not defined&#125;2.var、let、const的区别 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。 同一个变量只能使用一种方式声明，不然会报错 12345678910111213141516171819202122232425262728293031323334353637// 块作用域&#123; var a = 1; let b = 2; const c = 3; // c = 4; // 报错 // let a = 'a'; // 报错 注：是上面 var a = 1; 那行报错 // var b = 'b'; // 报错：本行报错 // const a = 'a1'; // 报错 注：是上面 var a = 1; 那行报错 // let c = 'c'; // 报错：本行报错 var aa; let bb; // const cc; // 报错 console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 console.log(aa); // undefined console.log(bb); // undefined&#125;console.log(a); // 1// console.log(b); // 报错// console.log(c); // 报错// 函数作用域(function A() &#123; var d = 5; let e = 6; const f = 7; console.log(d); // 5 console.log(e); // 6 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到) console.log(f); // 7 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到)&#125;)();// console.log(d); // 报错// console.log(e); // 报错// console.log(f); // 报错 ————————————————版权声明：本文为CSDN博主「hot_cool」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/hot_cool/article/details/78302673","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-08-21T03:13:37.000Z","updated":"2019-08-21T14:10:27.062Z","comments":true,"path":"2019/08/21/正则表达式/","link":"","permalink":"http://yoursite.com/2019/08/21/正则表达式/","excerpt":"正则表达式 正则表达式是国际标准，跨越语言 正则表达式是一个规则，用于验证字符串","text":"正则表达式 正则表达式是国际标准，跨越语言 正则表达式是一个规则，用于验证字符串 基础 创建正则表达式的对象 创建正则表达式的对象 12345//var 变量 = new RegExp(\"正则表达式\",\"匹配模式\")//使用typeof检查正则对象，会返回object//RegExp(\"a\")这个正则表达式可以检查一个字符串是否含有alet reg = new RegExp(\"a\",\"i\")let str = \"a\" 在构造函数中可以传递一个匹配模式作为第二个参数：可以是 i 忽略大小写 g 全局匹配模式 正则表达式的基本方法 test() 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false123let result = reg.test(str)console.log(result) //trueconsole.log(reg.test(\"bcbc\")) //false 严格区分大小写 使用字面量来创建正则表达式 语法：let 变量 = /正则表达式/匹配模式 1let reg = /a/i 创建一个正则表达式，检查一个字符串中是否有a或b 12345678let reg = /a|b/i //使用 | 表示或者的意思console.log(reg.test(\"ac\")) //true``` - 创建一个正则表达式检查一个字符串中是否有字母``` javascriptlet reg = /[a-z]/i //[]里的内容也是或的关系console.log(reg.test(\"h\")) //true 检查一个字符串中是否含有abc 或 adc 或 aec 12let reg = /a[bde]c/console.log(reg.test(\"aec\")) //true [^ ] 除了 12let reg = /[^ab]/iconsole.log(reg.test(\"abc\")) //true 除了ab还有c 支持正则表达式的String对象的方法 split()可以将一个字符串拆分为一个数组 123let str = \"1a2b3c4d5e6f7\"let result = str.split(/[A-z]/)console.log(result) //\"1,2,3,4,5,6,7\" search()可以搜索字符串中是否含有指定内容,如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1，它可以接收一个正则表达式作为参数，然后回根据正则表达式去检索字符串,不会全局匹配 12345678let str = \"hello abc hello abc\"result = str.search(\"abc\")console.log(result) //6//搜索字符串中是否含有abc 或aec 或afcstr = \"hello hello aec afc\"result = str.search(/a[bef]c/)console.log(result) //12 match()可以根据正则表达式，从一个字符串中将符合条件的内容提取出来,默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索，我们可以设置为全局匹配模式，这样就会匹配到所有的内容 123let str = \"1a2b3c4d5e6f7A8\"let result = str.match(/[a-z]/gi)console.log(result) //\"a,b,c,d,e,f,A\" replace()可以将字符串中指定内容替换为新的内容，参数：被替换的内容、新的内容，默认只会替换第一个 123let str = \"1a2a3c4d5e6f7A8\"let result = str.replace(/a/gi,\"@\")console.log(result) //\"1@2@3c4d5e6f7@8\" 语法 量词 通过变量可以设置一个内容出现的次数 量词只对它前边的一个内容起作用 {n}正好出现 n 次 {m,n} 出现 m 到 n 次 {m,} 出现 m 次以上 + 至少一个，相当于{1,} * 0个或多个，相当于{0,} ? 0个或1个，相当于{0,1} 12345678let reg = /a&#123;3&#125;/ //aaareg = /(ab)&#123;3&#125;/ //abababreg = /ab&#123;3&#125;c/ //abbbcreg = /ab&#123;1,3&#125;c/ //abc abbc abbbcreg = /ab+c/ //至少一个breg = /ab*c/ //有没有b都行reg = /ab?c/ //0个或1个b 检查一个字符串是否以a开头结尾 ^ 表示开头 1reg = /^a/ $表示结尾 1reg = /a$/ 如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式 12reg = /^a$/ reg = /^a|a$/ //以a开头或以a结尾 练习：创建一个正则表达式，用来检查一个字符串是否是一个合法手机号 手机号的规则：11位、以1开头、第二位3-9任意数字、三位以后任意数字9个 ^1 [3-9] [0-9]{9}$12345let phoneStr = \"13567890123\"let wrongStr = \"10567890123\"let phoneReg = /^1[3-9][0-9]&#123;9&#125;$/console.log(phoneReg.test(phoneStr)) //trueconsole.log(phoneReg.test(wrongStr)) //false 检查一个字符串中是否含有. . 表示任意字符 在正则表达式中使用\\作为转义字符 . 来表示 . \\ 来表示 \\ 注意：使用构造函数时，由于它的参数是一个字符串，而\\是字符串中转义字符，如果要使用\\则需要使用\\来代替 有特殊意义的字符 \\w 任意字母、数字、下划线 [A-z0-9_] \\W 除了字母、数字、下划线 [^A-z0-9_] \\d 任意数字 [0-9] \\D 除了数字 [^0-9] \\s 空格 \\S 除了空格 \\b 单词边界 （/\\bchild\\b/ 和 children） \\B 除了单词边界123//去掉开头和结尾的空格let str = \" hello world \"str = str.replace(/^\\s*|\\s$/g,\"\") 邮箱的正则 电子邮箱的格式 任意字母数字下划线 . 任意字母数字下划线 @ 任意字母数字 . 任意字母（2-5位） . 任意字母（2-5位） 正则写法: \\w{3,} (.\\w+)* @ [A-z0-9]+ (.[A-z]{2,5}){1,2} 代码 1let emailReg = /^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"js中常用的数组和字符串方法","slug":"js中数组方法","date":"2019-08-19T06:31:27.000Z","updated":"2019-08-19T08:25:39.519Z","comments":true,"path":"2019/08/19/js中数组方法/","link":"","permalink":"http://yoursite.com/2019/08/19/js中数组方法/","excerpt":"数组栈方法 push() 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。该方法会改变数组的长度。 pop() 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。该方法会改变数组的长度。","text":"数组栈方法 push() 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。该方法会改变数组的长度。 pop() 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。该方法会改变数组的长度。 队列方法 shift() 能够移除数组中的第一项并返回该项，同时将数组长度减1。该方法会改变数组的长度。 unshift() 在数组前端添加任意个项并返回新数组的长度。该方法会改变数组的长度。 重排序方法 reverse() 用于颠倒数组中元素的顺序,会改变原来的数组，而不会创建新的数组。 sort() 对数组中的元素照字符编码的顺序进行排序,数组在原数组上进行排序，不生成副本,要想按照数值大小排序，还要使用一个排序函数。 操作方法 concat() 基于当前数组中的所有项创建一个新数组。具体来说，会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。 slice() 基于当前数组中的一或多个项创建一个新数组。在只有一个参数的情况下，返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法会返回起始和结束位置之间的项（不包括结束位置的项）。slice()方法不会影响原始数组。 splice() 主要用途是向数组的中部插入项。删除：两个参数，要删除的第一项的位置和要删除的项数；插入：三个参数，起始位置、0和要插入的项；替换：三个参数，起始位置、要删除的项数和要插入的任意数量的项。splice()方法始终都会返回一个包含从原始数组中删除的项的数组（如果没删，就返回空数组）。该方法会改变原始数组。 位置方法 indexOf() 接收两个参数，要查找的项和（可选）表示查找起点位置的索引，indexOf()从数组的开头开始（位置0）往后查找.返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。 lastIndexOf() 从数组的末尾开始向前查找。 迭代方法都会对数组中的每一项运行给定函数，都不会改变原始数组。 every() 如果该函数对每一项都返回true，则返回true。 filter() 返回该函数会返回true的项组成的数组。 forEach() 这个方法没有返回值。 map() 返回每次函数调用的结果组成的数组。 some() 如果该函数对任一项返回true，则返回true。 归并方法 reduce() 接收两个参数，在每一项上调用的函数和（可选）作为归并基础的初始值。传给reduce()的函数接受四个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。 reduceRight() 从数组的最后一项开始，向前遍历到第一项。 字符串 charAt() 接收一个参数，字符在字符串中的位置，返回指定位置的字符。 concat() 方法同数组。 indexOf() 方法同数组。区分大小写。 includes() 用于判断字符串是否包含指定字串，如果找到匹配的字符串则返回true，否则返回false。 match() 在字符串内检索指定的项，或找到一个或多个（是否具有标志g）正则表达式的匹配。如果没有找到，将返回null。否则，返回一个数组。 repeat() 接收一个参数，要复制的次数。返回复制指定次数并连接在一起的新字符串。 replace() 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。返回一个新的字符串。该方法不会改变原始字符串。 search() 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回相匹配的String对象起始位置。没有找到则返回-1。 slice() 方法同数组。 split() 用于把一个字符串分割成字符串数组。split() 方法不改变原始字符串。 substr() 可在字符串中抽取从开始下标开始的指定数目的字符。参数是字串的开始位置和长度。该方法不会改变源字符串。 substring() 用于提取字符串中介于两个指定下标之间的字符。返回的子串包括开始处的字符，不包括结束处的字符。 toLowerCase() &amp; toUpperCase() 用于把字符串转换为小/大写，该方法不会改变源字符串。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"关于如何搭建自己的hexo博客","slug":"关于如何搭建自己的hexo博客","date":"2019-08-15T03:36:04.000Z","updated":"2019-08-16T12:03:24.756Z","comments":true,"path":"2019/08/15/关于如何搭建自己的hexo博客/","link":"","permalink":"http://yoursite.com/2019/08/15/关于如何搭建自己的hexo博客/","excerpt":"一、环境准备 下载node.js(在官网下载就可以了，之后无脑点击下一步安装，安装好之后可以在cmd( win键 + R 打开运行，在里面输入cmd就可以进入cmd了 )里输入: node –version 检查版本，有版本就说明安装好了，在下载node的时候也会绑定下载npm，用同样的方法在cmd里输入: npm –version 看下npm装上了没有) npm上下载的资源比较慢，所以我们用国内的淘宝镜像cnpm，用npm安装cnpm: npm install -g cnpm –registry=https://registry.npm.taobao.org (记得cnpm -v检查下版本哦)","text":"一、环境准备 下载node.js(在官网下载就可以了，之后无脑点击下一步安装，安装好之后可以在cmd( win键 + R 打开运行，在里面输入cmd就可以进入cmd了 )里输入: node –version 检查版本，有版本就说明安装好了，在下载node的时候也会绑定下载npm，用同样的方法在cmd里输入: npm –version 看下npm装上了没有) npm上下载的资源比较慢，所以我们用国内的淘宝镜像cnpm，用npm安装cnpm: npm install -g cnpm –registry=https://registry.npm.taobao.org (记得cnpm -v检查下版本哦) 下载Git，同样是在官网下载，下载安装完成后(记得安装的路径)在桌面一空白区域右键，看下是否出现了两个Git GUI 和 Git Bash的选项，如果有的话在cmd中输入: git –version ，查看一下版本号，可能这里cmd提示说找不到git这个命令，这就表明需要添加环境变量，具体操作自行百度，非常简单，path里加一个路径即可 安装hexo: cnpm install -g hexo-cli (hexo -v检查版本) 二、创建博客 创建一个文件夹存放博客的所有资源,可以在cmd里直接创建，或者去到某个文件夹里新建文件夹都是可以的(我这里直接在默认的我的文档下创建了一个叫blog的文件夹) 1C:\\Users\\23163&gt;mkdir blog 在cmd中移动到你这个新建文件夹中(我这里直接cd blog就可以了) 初始化hexo，看到终端提示：INFO Start blogging with Hexo! 就说明初始化成功了 1C:\\Users\\23163\\blog&gt;hexo init 在cmd中执行命令: hexo s (hexo serve的简写形式)，就可以在本地服务器运行你的hexo博客了，会给一个默认的端口( INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. )，想要退出的话，就像它提示的那样在终端输入Ctrl+C就可以了 在cmd中执行命令: hexo n “我的第一篇博客文章” (hexo new “XXX”的简写形式)，就会为你创建一篇新的博客了，博客的格式为markdown，你可以通过vim或者vscode都可以对博客的内容进行操作 在cmd中执行命令: hexo clean 这一步是清除原有的静态文件(当你更新了配置、主题、内容有可能无法显示，直接清除原有的静态文件再创建新的静态文件是稳妥的方法) 在cmd中执行命令: hexo g (hexo generate的简写形式)，生成包括html、css、js、图片等各种静态文件 再次执行 hexo s 命令，就可以看到刚刚创建的文章被添加到博客里了 三、部署博客到Github 退出刚才在运行的本地博客，在cmd中执行命令,安装部署的工具(记得还是在之前新建的blog文件夹下) 1C:\\Users\\23163\\blog&gt;cnpm install --save hexo-deployer-git 需要你拥有一个GitHub账号，登录你的GitHub，创建一个仓库【create a new repository】，仓库名的格式为：Owner.github.io 其中Owner是你GitHub的名字，这里一定要用这个名字才可以，描述随便写就可以了，创建好仓库后，记录下它的https地址 打开blog文件夹中的_config.yml文件，移动到该文件内容的最底端#Depolyment部分，加上配置，这里的rope换成你自己刚才设置的地址就可以(敲代码的时候注意缩进为两格，冒号后面需要一个空格) 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/MrPand111/MrPand111.github.io.git branch: master 返回到cmd,执行命令: hexo d (hexo deploy的简写形式)，中途需要你登录GitHub账户，登录一下就可以，如果遇到了 Error: Spawn failed，应该是你之前没有在git配置过信息导致的，在cmd中执行: git config –global user.email “you@example.com“ 和 git config –global user.name “Your Name” (双引号里输入你的GitHub信息就行)，然后再次hexo d估计就没问题了 到这里你就可以通过刚才设置的 Owner.github.io 来访问自己的博客了，这里拿我的博客作为示范: https://mrpand111.github.io/ 欢迎大家一起来讨论和深入研究hexo鸭！","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"JS实现一个简单的计算器","slug":"我的第一篇博客文章","date":"2019-08-15T01:15:04.000Z","updated":"2019-08-16T12:53:37.128Z","comments":true,"path":"2019/08/15/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2019/08/15/我的第一篇博客文章/","excerpt":"Part1 HTML + CSShtml部分的话非常简单，利用表格就可以完成,值得一提的就是显示框这里虽然用的是input，但是要加一个只读属性","text":"Part1 HTML + CSShtml部分的话非常简单，利用表格就可以完成,值得一提的就是显示框这里虽然用的是input，但是要加一个只读属性 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id=\"counter\"&gt; &lt;div class=\"counter_window\"&gt;&lt;input type=\"text\" id=\"counter_window\" readonly=\"readonly\"&gt;&lt;/div&gt; &lt;table id=\"table1\"&gt; &lt;tr&gt; &lt;td&gt;7&lt;/td&gt; &lt;td&gt;8&lt;/td&gt; &lt;td&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;.&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td style=\"font-weight: normal;font-size: 14px;\"&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table id=\"table2\"&gt; &lt;tr&gt;&lt;td&gt;/&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;x&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;+&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=\"background: rgb(255, 214, 80); color: white;\"&gt;=&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt; css也是用一些基本的把大小位置固定就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#counter&#123; width:300px; height:507px; border: 1px solid black; margin:100px auto;&#125;.counter_window&#123; width:300px; height:100px; text-align: center;&#125;#counter_window&#123; width:295px; height:100px; text-align: right; font-size: 20px;&#125;#table1&#123; width:215px; height:400px; margin-top:7px; margin-left:10px; float:left;&#125;#table1 td&#123; width:68px;&#125;#table2&#123; width:75px; height:400px; margin-top:7px; float:left; background:#eee;&#125;td&#123; text-align: center; font-size: 18px; cursor: pointer; font-weight: bold;&#125;td:hover&#123; background: skyblue;&#125; Part2 JSjs这里我选择了一个比较投机的方法，eval函数，将字符串转换成js可以看懂的式子计算出来并返回结果，这个函数可以说是双刃剑，优点在于快速方便的解析字符串，缺点就是可以解析一些恶意的代码 1234567891011121314151617181920212223242526//获取视窗const cWindow = document.getElementById('counter_window')//定义要计算的字符串和计算的结果let allStr = \"\"let result//将键入的数字添加到待计算的字符串中function Add(num)&#123; allStr =allStr + num cWindow.value = allStr&#125;//计算字符串function Computed()&#123; result = String(eval(allStr)) allStr = Number(result) cWindow.value = allStr&#125;//Del删除字符串function Del()&#123; allStr = String(cWindow.value).slice(0,allStr.length-1) console.log(allStr) cWindow.value = allStr&#125; Part3 完整代码完成了这个计算器后，应该就对js自定义函数的应用有了一点了解吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;简单计算器&lt;/title&gt; &lt;style&gt; #counter&#123; width:300px; height:507px; border: 1px solid black; margin:100px auto; &#125; .counter_window&#123; width:300px; height:100px; text-align: center; &#125; #counter_window&#123; width:295px; height:100px; text-align: right; font-size: 20px; &#125; #table1&#123; width:215px; height:400px; margin-top:7px; margin-left:10px; float:left; &#125; #table1 td&#123; width:68px; &#125; #table2&#123; width:75px; height:400px; margin-top:7px; float:left; background:#eee; &#125; td&#123; text-align: center; font-size: 18px; cursor: pointer; font-weight: bold; &#125; td:hover&#123; background: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"counter\"&gt; &lt;div class=\"counter_window\"&gt;&lt;input type=\"text\" id=\"counter_window\" readonly=\"readonly\"&gt;&lt;/div&gt; &lt;table id=\"table1\"&gt; &lt;tr&gt; &lt;td onclick=\"Add('7')\"&gt;7&lt;/td&gt; &lt;td onclick=\"Add('8')\"&gt;8&lt;/td&gt; &lt;td onclick=\"Add('9')\"&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=\"Add('4')\"&gt;4&lt;/td&gt; &lt;td onclick=\"Add('5')\"&gt;5&lt;/td&gt; &lt;td onclick=\"Add('6')\"&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=\"Add('1')\"&gt;1&lt;/td&gt; &lt;td onclick=\"Add('2')\"&gt;2&lt;/td&gt; &lt;td onclick=\"Add('3')\"&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=\"Add('.')\"&gt;.&lt;/td&gt; &lt;td onclick=\"Add('0')\"&gt;0&lt;/td&gt; &lt;td onclick=\"Del()\" style=\"font-weight: normal;font-size: 14px;\"&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table id=\"table2\"&gt; &lt;tr&gt;&lt;td onclick=\"Add('/')\"&gt;/&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td onclick=\"Add('*')\"&gt;x&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td onclick=\"Add('-')\"&gt;-&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td onclick=\"Add('+')\"&gt;+&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=\"background: rgb(255, 214, 80); color: white;\" onclick=\"Computed()\"&gt;=&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const cWindow = document.getElementById('counter_window') let allStr = \"\" let result function Add(num)&#123; allStr =allStr + num cWindow.value = allStr &#125; function Computed()&#123; result = String(eval(allStr)) if(result.length === 18)&#123; result = result.slice(0,17) &#125; allStr = Number(result) cWindow.value = allStr &#125; function Del()&#123; allStr = String(cWindow.value).slice(0,allStr.length-1) console.log(allStr) cWindow.value = allStr &#125;&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]}]}